<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Node 节点 - Cease to struggle and you cease to live</title>
  <meta name="author" content="JesseChiu">
  
  <meta name="description" content="DOM的概念DOM是文档对象模型（Document Object Model）的简称，它的基本思想是把结构化文档（比如HTML和XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口，以达到使用编程语言操作文档的目的（比如增删内容">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Node 节点"/>
  <meta property="og:site_name" content="Cease to struggle and you cease to live"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Cease to struggle and you cease to live" type="application/atom+xml">
  
  
    <link href="/favicon.ico" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/spacelab.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <!-- analytics -->
  



</head>


 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Cease to struggle and you cease to live</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="">
			  <i class="fa fa-rss"></i>Rss
			</a>
		  </li>
		  
		  <li>
			<a href="/sitemap.xml" title="">
			  <i class="fa fa-sitemap"></i>Sitemap
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> Node 节点</h1>
		</div>		
	



<!-- 不蒜子统计 -->

        <span id="busuanzi_container_page_pv" style='display:none'>
              <i class="icon-smile icon"></i> 本文总阅读量: <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> 次
        </span>






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="DOM的概念"><a href="#DOM的概念" class="headerlink" title="DOM的概念"></a>DOM的概念</h2><p>DOM是文档对象模型（Document Object Model）的简称，它的基本思想是把结构化文档（比如HTML和XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口，以达到使用编程语言操作文档的目的（比如增删内容）。所以，DOM可以理解成文档（HTML文档、XML文档和SVG文档）的编程接口。</p>
<p>DOM有自己的国际标准，目前的通用版本是<a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html" target="_blank" rel="noopener">DOM 3</a>，下一代版本<a href="http://www.w3.org/TR/dom/" target="_blank" rel="noopener">DOM 4</a>正在拟定中。本章介绍的就是JavaScript对DOM标准的实现和用法。</p>
<p>严格地说，DOM不属于JavaScript，但是操作DOM是JavaScript最常见的任务，而JavaScript也是最常用于DOM操作的语言。所以，DOM往往放在JavaScript里面介绍。</p>
<h2 id="节点的概念"><a href="#节点的概念" class="headerlink" title="节点的概念"></a>节点的概念</h2><p>DOM的最小组成单位叫做节点（node），一个文档的树形结构（DOM树），就是由各种不同类型的节点组成。</p>
<p>对于HTML文档，节点主要有以下六种类型：Document节点、DocumentType节点、Element节点、Attribute节点、Text节点和DocumentFragment节点。</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Document</td>
<td>文档节点</td>
<td>整个文档（window.document）</td>
</tr>
<tr>
<td>DocumentType</td>
<td>文档类型节点</td>
<td>文档的类型（比如&lt;!DOCTYPE html&gt;）</td>
</tr>
<tr>
<td>Element</td>
<td>元素节点</td>
<td>HTML元素（比如&lt;body&gt;、&lt;a&gt;等）</td>
</tr>
<tr>
<td>Attribute</td>
<td>属性节点</td>
<td>HTML元素的属性（比如class=”right”）</td>
</tr>
<tr>
<td>Text</td>
<td>文本节点</td>
<td>HTML文档中出现的文本</td>
</tr>
<tr>
<td>DocumentFragment</td>
<td>文档碎片节点</td>
<td>文档的片段</td>
</tr>
</tbody></table>
<p>浏览器原生提供一个Node对象，上表所有类型的节点都是Node对象派生出来的。也就是说，它们都继承了Node的属性和方法。</p>
<h2 id="Node节点的属性"><a href="#Node节点的属性" class="headerlink" title="Node节点的属性"></a>Node节点的属性</h2><h3 id="nodeName，nodeType"><a href="#nodeName，nodeType" class="headerlink" title="nodeName，nodeType"></a>nodeName，nodeType</h3><p><code>nodeName</code>属性返回节点的名称，<code>nodeType</code>属性返回节点类型的常数值。具体的返回值，可查阅下方的表格。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>nodeName</th>
<th>nodeType</th>
</tr>
</thead>
<tbody><tr>
<td>DOCUMENT_NODE</td>
<td>#document</td>
<td>9</td>
</tr>
<tr>
<td>ELEMENT_NODE</td>
<td>大写的HTML元素名</td>
<td>1</td>
</tr>
<tr>
<td>ATTRIBUTE_NODE</td>
<td>等同于Attr.name</td>
<td>2</td>
</tr>
<tr>
<td>TEXT_NODE</td>
<td>#text</td>
<td>3</td>
</tr>
<tr>
<td>DOCUMENT_FRAGMENT_NODE</td>
<td>#document-fragment</td>
<td>11</td>
</tr>
<tr>
<td>DOCUMENT_TYPE_NODE</td>
<td>等同于DocumentType.name</td>
<td>10</td>
</tr>
</tbody></table>
<p>以<code>document</code>节点为例，它的<code>nodeName</code>属性等于<code>#document</code>，<code>nodeType</code>属性等于9。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeName <span class="comment">// "#document"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType <span class="comment">// 9</span></span></pre></td></tr></table></figure>

<p>通常来说，使用<code>nodeType</code>属性确定一个节点的类型，比较方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'a'</span>).nodeType === <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'a'</span>).nodeType === Node.ELEMENT_NODE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span></pre></td></tr></table></figure>

<p>上面两种写法是等价的。</p>
<h3 id="ownerDocument，nextSibling，previousSibling，parentNode，parentElement"><a href="#ownerDocument，nextSibling，previousSibling，parentNode，parentElement" class="headerlink" title="ownerDocument，nextSibling，previousSibling，parentNode，parentElement"></a>ownerDocument，nextSibling，previousSibling，parentNode，parentElement</h3><p>以下属性返回当前节点的相关节点。</p>
<p><strong>（1）ownerDocument</strong></p>
<p>ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = p.ownerDocument;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">d === <span class="built_in">document</span> <span class="comment">// true</span></span></pre></td></tr></table></figure>

<p>document对象本身的ownerDocument属性，返回null。</p>
<p><strong>（2）nextSibling</strong></p>
<p>nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。注意，该属性还包括文本节点和评论节点。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'div-01'</span>).firstChild;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (el) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(i + <span class="string">'. '</span> + el.nodeName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  el = el.nextSibling;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  i++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码遍历<code>div-01</code>节点的所有子节点。</p>
<p><strong>（3）previousSibling</strong></p>
<p>previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// html代码如下</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;a&gt;&lt;b1 id="b1"/&gt;&lt;b2 id="b2"/&gt;&lt;/a&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"b1"</span>).previousSibling <span class="comment">// null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"b2"</span>).previousSibling.id <span class="comment">// "b1"</span></span></pre></td></tr></table></figure>

<p>对于当前节点前面有空格，则<code>previousSibling</code>属性会返回一个内容为空格的文本节点。</p>
<p><strong>（4）parentNode</strong></p>
<p><code>parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：<code>element</code>节点、<code>document</code>节点和<code>documentfragment</code>节点。</p>
<p>下面代码是如何从父节点移除指定节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentNode) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  node.parentNode.removeChild(node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对于document节点和documentfragment节点，它们的父节点都是null。另外，对于那些生成后还没插入DOM树的节点，父节点也是null。</p>
<p><strong>（5）parentElement</strong></p>
<p>parentElement属性返回当前节点的父Element节点。如果当前节点没有父节点，或者父节点类型不是Element节点，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentElement) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  node.parentElement.style.color = <span class="string">"red"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码设置指定节点的父Element节点的CSS属性。</p>
<p>在IE浏览器中，只有Element节点才有该属性，其他浏览器则是所有类型的节点都有该属性。</p>
<h3 id="textContent，nodeValue"><a href="#textContent，nodeValue" class="headerlink" title="textContent，nodeValue"></a>textContent，nodeValue</h3><p>以下属性返回当前节点的内容。</p>
<p><strong>（1）textContent</strong></p>
<p>textContent属性返回当前节点和它的所有后代节点的文本内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"divA"</span>).textContent</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is some text</span></span></pre></td></tr></table></figure>

<p>上面代码的textContent属性，自动忽略当前节点内部的HTML标签，返回所有文本内容。</p>
<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有它原来的子节点。它还有一个好处，就是自动对HTML标签转义。这很适合用于用户提供的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>).textContent = <span class="string">'&lt;p&gt;GoodBye!&lt;/p&gt;'</span>;</span></pre></td></tr></table></figure>

<p>上面代码在插入文本时，会将p标签解释为文本，即&amp;lt;p&amp;gt;，而不会当作标签处理。</p>
<p>对于Text节点和Comment节点，该属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括Comment节点。如果一个节点没有子节点，则返回空字符串。</p>
<p>document节点和doctype节点的textContent属性为null。如果要读取整个文档的内容，可以使用<code>document.documentElement.textContent</code>。</p>
<p>在IE浏览器，所有Element节点都有一个innerText属性。它与textContent属性基本相同，但是有几点区别。</p>
<ul>
<li><p>innerText受CSS影响，textContent不受。比如，如果CSS规则隐藏（hidden）了某段文本，innerText就不会返回这段文本，textContent则照样返回。</p>
</li>
<li><p>innerText返回的文本，会过滤掉空格、换行和回车键，textContent则不会。</p>
</li>
<li><p>innerText属性不是DOM标准的一部分，Firefox浏览器甚至没有部署这个属性，而textContent是DOM标准的一部分。</p>
</li>
</ul>
<p><strong>（2）nodeValue</strong></p>
<p>nodeValue属性返回或设置当前节点的值，格式为字符串。但是，该属性只对Text节点、Comment节点、XML文档的CDATA节点有效，其他类型的节点一律返回null。</p>
<p>因此，nodeValue属性一般只用于Text节点。对于那些返回null的节点，设置nodeValue属性是无效的。</p>
<h3 id="childNodes，firstChild，lastChild"><a href="#childNodes，firstChild，lastChild" class="headerlink" title="childNodes，firstChild，lastChild"></a>childNodes，firstChild，lastChild</h3><p>以下属性返回当前节点的子节点。</p>
<p><strong>（1）childNodes</strong></p>
<p>childNodes属性返回一个NodeList集合，成员包括当前节点的所有子节点。注意，除了HTML元素节点，该属性返回的还包括Text节点和Comment节点。如果当前节点不包括任何子节点，则返回一个空的NodeList集合。由于NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ulElementChildNodes = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).childNodes;</span></pre></td></tr></table></figure>

<p><strong>（2）firstChild</strong></p>
<p><code>firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>（注意，不是<code>undefined</code>）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"para-01"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>First span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'para-01'</span>).firstChild.nodeName</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">  ) <span class="comment">// "span"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素的第一个子节点是<code>span</code>元素。</p>
<p>注意，<code>firstChild</code>返回的除了HTML元素子节点，还可能是文本节点或评论节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"para-01"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>First span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'para-01'</span>).firstChild.nodeName</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">  ) <span class="comment">// "#text"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p>
<p><strong>（3）lastChild</strong></p>
<p>lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。</p>
<h3 id="baseURI"><a href="#baseURI" class="headerlink" title="baseURI"></a>baseURI</h3><p>baseURI属性返回一个字符串，由当前网页的协议、域名和所在的目录组成，表示当前网页的绝对路径。如果无法取到这个值，则返回null。浏览器根据这个属性，计算网页上的相对路径的URL。该属性为只读。</p>
<p>通常情况下，该属性由当前网址的URL（即window.location属性）决定，但是可以使用HTML的&lt;base&gt;标签，改变该属性的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.example.com/page.html"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://www.example.com/page.html"</span>&gt;</span></span></pre></td></tr></table></figure>

<p>该属性不仅document对象有（<code>document.baseURI</code>），元素节点也有（<code>element.baseURI</code>）。通常情况下，它们的值是相同的。</p>
<h2 id="Node节点的方法"><a href="#Node节点的方法" class="headerlink" title="Node节点的方法"></a>Node节点的方法</h2><h3 id="appendChild-，hasChildNodes"><a href="#appendChild-，hasChildNodes" class="headerlink" title="appendChild()，hasChildNodes()"></a>appendChild()，hasChildNodes()</h3><p>以下方法与子节点相关。</p>
<p><strong>（1）appendChild()</strong></p>
<p><code>appendChild</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.appendChild(p);</span></pre></td></tr></table></figure>

<p>如果参数节点是文档中现有的其他节点，appendChild方法会将其从原来的位置，移动到新位置。</p>
<p><strong>（2）hasChildNodes()</strong></p>
<p><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( foo.hasChildNodes() ) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  foo.removeChild( foo.childNodes[<span class="number">0</span>] );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码表示，如果foo节点有子节点，就移除第一个子节点。</p>
<p><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以遍历当前节点的所有后代节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOMComb</span>(<span class="params">parent, callback</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (parent.hasChildNodes()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> node = parent.firstChild; node; node = node.nextSibling) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      DOMComb(node, callback);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  callback.call(parent);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码的<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printContent</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.nodeValue) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.nodeValue);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">DOMComb(<span class="built_in">document</span>.body, printContent);</span></pre></td></tr></table></figure>

<h3 id="cloneNode-，insertBefore-，removeChild-，replaceChild"><a href="#cloneNode-，insertBefore-，removeChild-，replaceChild" class="headerlink" title="cloneNode()，insertBefore()，removeChild()，replaceChild()"></a>cloneNode()，insertBefore()，removeChild()，replaceChild()</h3><p>下面方法与节点操作有关。</p>
<p><strong>（1）cloneNode()</strong></p>
<p>cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是false，即不克隆子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneUL = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).cloneNode(<span class="literal">true</span>);</span></pre></td></tr></table></figure>

<p>需要注意的是，克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>
<p>克隆一个节点之后，DOM树有可能出现两个有相同ID属性（即<code>id=&quot;xxx&quot;</code>）的HTML元素，这时应该修改其中一个HTML元素的ID属性。</p>
<p><strong>（2）insertBefore()</strong></p>
<p>insertBefore方法用于将某个节点插入当前节点的指定位置。它接受两个参数，第一个参数是所要插入的节点，第二个参数是当前节点的一个子节点，新的节点将插在这个节点的前面。该方法返回被插入的新节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text1 = <span class="built_in">document</span>.createTextNode(<span class="string">'1'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">li.appendChild(text1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ul.insertBefore(li,ul.firstChild);</span></pre></td></tr></table></figure>

<p>上面代码在ul节点的最前面，插入一个新建的li节点。</p>
<p>如果insertBefore方法的第二个参数为null，则新节点将插在当前节点的最后位置，即变成最后一个子节点。</p>
<p>将新节点插在当前节点的最前面（即变成第一个子节点），可以使用当前节点的firstChild属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">parentElement.insertBefore(newElement, parentElement.firstChild);</span></pre></td></tr></table></figure>

<p>上面代码中，如果当前节点没有任何子节点，<code>parentElement.firstChild</code>会返回null，则新节点会插在当前节点的最后，等于是第一个子节点。</p>
<p>由于不存在insertAfter方法，如果要插在当前节点的某个子节点后面，可以用insertBefore方法结合nextSibling属性模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">parentDiv.insertBefore(s1, s2.nextSibling);</span></pre></td></tr></table></figure>

<p>上面代码可以将s1节点，插在s2节点的后面。如果s2是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回null，这时s1节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在s2的后面。</p>
<p><strong>（3）removeChild()</strong></p>
<p>removeChild方法接受一个子节点作为参数，用于从当前节点移除该节点。它返回被移除的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="built_in">document</span>.getElementById(<span class="string">'A'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">divA.parentNode.removeChild(divA);</span></pre></td></tr></table></figure>

<p>上面代码是如何移除一个指定节点。</p>
<p>下面是如何移除当前节点的所有子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"top"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (element.firstChild) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  element.removeChild(element.firstChild);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>被移除的节点依然存在于内存之中，但是不再是DOM的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点。</p>
<p><strong>（4）replaceChild()</strong></p>
<p>replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。它接受两个参数，第一个参数是用来替换的新节点，第二个参数将要被替换走的子节点。它返回被替换走的那个节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">replacedNode = parentNode.replaceChild(newChild, oldChild);</span></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="built_in">document</span>.getElementById(<span class="string">'A'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newSpan = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">newSpan.textContent = <span class="string">'Hello World!'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">divA.parentNode.replaceChild(newSpan,divA);</span></pre></td></tr></table></figure>

<p>上面代码是如何替换指定节点。</p>
<h3 id="contains-，compareDocumentPosition-，isEqualNode"><a href="#contains-，compareDocumentPosition-，isEqualNode" class="headerlink" title="contains()，compareDocumentPosition()，isEqualNode()"></a>contains()，compareDocumentPosition()，isEqualNode()</h3><p>下面方法用于节点的互相比较。</p>
<p><strong>（1）contains()</strong></p>
<p>contains方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contains(node)</span></pre></td></tr></table></figure>

<p>上面代码检查某个节点，是否包含在当前文档之中。</p>
<p>注意，如果将当前节点传入contains方法，会返回true。虽然从意义上说，一个节点不应该包含自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nodeA.contains(nodeA) <span class="comment">// true</span></span></pre></td></tr></table></figure>

<p><strong>（2）compareDocumentPosition()</strong></p>
<p>compareDocumentPosition方法的用法，与contains方法完全一致，返回一个7个比特位的二进制值，表示参数节点与当前节点的关系。</p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>数值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>000000</td>
<td>0</td>
<td>两个节点相同</td>
</tr>
<tr>
<td>000001</td>
<td>1</td>
<td>两个节点不在同一个文档（即有一个节点不在当前文档）</td>
</tr>
<tr>
<td>000010</td>
<td>2</td>
<td>参数节点在当前节点的前面</td>
</tr>
<tr>
<td>000100</td>
<td>4</td>
<td>参数节点在当前节点的后面</td>
</tr>
<tr>
<td>001000</td>
<td>8</td>
<td>参数节点包含当前节点</td>
</tr>
<tr>
<td>010000</td>
<td>16</td>
<td>当前节点包含参数节点</td>
</tr>
<tr>
<td>100000</td>
<td>32</td>
<td>浏览器的私有用途</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id="writeroot"&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//   &lt;form&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//     &lt;input id="test" /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//   &lt;/form&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;/div&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">'writeroot'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">x.compareDocumentPosition(y) <span class="comment">// 20</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">y.compareDocumentPosition(x) <span class="comment">// 10</span></span></pre></td></tr></table></figure>

<p>上面代码中，节点x包含节点y，而且节点y在节点x的后面，所以第一个compareDocumentPosition方法返回20（010100），第二个compareDocumentPosition方法返回10（0010010）。</p>
<p>由于compareDocumentPosition返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head.compareDocumentPosition(body) &amp; <span class="number">4</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文档结构正确"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"&lt;head&gt; 不能在 &lt;body&gt; 前面"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中，compareDocumentPosition的返回值与4（又称掩码）进行与运算（&amp;），得到一个布尔值，表示head是否在body前面。</p>
<p>在这个方法的基础上，可以部署一些特定的函数，检查节点的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Node.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> !!(<span class="keyword">this</span>.compareDocumentPosition(arg) &amp; <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">nodeA.before(nodeB)</span></pre></td></tr></table></figure>

<p>上面代码在Node对象上部署了一个before方法，返回一个布尔值，表示参数节点是否在当前节点的前面。</p>
<p><strong>（3）isEqualNode()</strong></p>
<p>isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetEl = <span class="built_in">document</span>.getElementById(<span class="string">"targetEl"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstDiv = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">targetEl.isEqualNode(firstDiv)</span></pre></td></tr></table></figure>

<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><p>normailize方法用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">wrapper.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Part 1 "</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">wrapper.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Part 2 "</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">wrapper.childNodes.length <span class="comment">// 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">wrapper.normalize();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">wrapper.childNodes.length <span class="comment">// 1</span></span></pre></td></tr></table></figure>

<p>上面代码使用normalize方法之前，wrapper节点有两个Text子节点。使用normalize方法之后，两个Text子节点被合并成一个。</p>
<p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text节点》章节，了解更多内容。</p>
<h2 id="NodeList接口，HTMLCollection接口"><a href="#NodeList接口，HTMLCollection接口" class="headerlink" title="NodeList接口，HTMLCollection接口"></a>NodeList接口，HTMLCollection接口</h2><p>节点对象都是单个节点，但是有时会需要一种数据结构，能够容纳多个节点。DOM提供两种接口，用于部署这种节点的集合：NodeList接口和HTMLCollection接口。</p>
<h3 id="NodeList接口"><a href="#NodeList接口" class="headerlink" title="NodeList接口"></a>NodeList接口</h3><p>有些属性和方法返回的是一组节点，比如Node.childNodes、document.querySelectorAll()。它们返回的都是一个部署了NodeList接口的对象。</p>
<p>NodeList接口有时返回一个动态集合，有时返回一个静态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。Node.childNodes返回的，就是一个动态集合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">parent.childNodes.length <span class="comment">// 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">parent.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">parent.childNodes.length <span class="comment">// 3</span></span></pre></td></tr></table></figure>

<p>上面代码中，<code>parent.childNodes</code>返回的是一个部署了NodeList接口的对象。当parent节点新增一个子节点以后，该对象的成员个数就增加了1。</p>
<p>document.querySelectorAll方法返回的是一个静态，DOM内部的变化，并不会实时反映在该方法的返回结果之中。</p>
<p>NodeList接口提供length属性和数字索引，因此可以像数组那样，使用数字索引取出每个节点，但是它本身并不是数组，不能使用pop或push之类数组特有的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的继承链</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">myArray --&gt; <span class="built_in">Array</span>.prototype --&gt; <span class="built_in">Object</span>.prototype --&gt; <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeList的继承链</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">myNodeList --&gt; NodeList.prototype --&gt; <span class="built_in">Object</span>.prototype --&gt; <span class="literal">null</span></span></pre></td></tr></table></figure>

<p>从上面的继承链可以看到，NodeList接口对象并不继承Array.prototype，因此不具有数组接口提供的方法。如果要在NodeList接口使用数组方法，可以将NodeList接口对象转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div_list = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div_array = <span class="built_in">Array</span>.prototype.slice.call(div_list);</span></pre></td></tr></table></figure>

<p>也可以通过下面的方法调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forEach = <span class="built_in">Array</span>.prototype.forEach;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">forEach.call(element.childNodes, <span class="function"><span class="keyword">function</span>(<span class="params">child</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  child.parentNode.style.color = <span class="string">'#0F0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码让数组的forEach方法在NodeList接口对象上调用。</p>
<p>不过，遍历NodeList接口对象的首选方法，还是使用for循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; myNodeList.length; ++i) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> item = myNodeList[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>不要使用for…in循环去遍历NodeList接口对象，因为for…in循环会将非数字索引的length属性和下面要讲到的item方法，也遍历进去，而且不保证各个成员遍历的顺序。</p>
<p>ES6新增的for…of循环，也可以正确遍历NodeList接口对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll( <span class="string">'input[type=checkbox]'</span> );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> list) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  item.checked = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>NodeList接口提供item方法，接受一个数字索引作为参数，返回该索引对应的成员。如果取不到成员，或者索引不合法，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nodeItem = nodeList.item(index)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> secondDiv = divs.item(<span class="number">1</span>);</span></pre></td></tr></table></figure>

<p>上面代码中，由于数字索引从零开始计数，所以取出第二个成员，要使用数字索引1。</p>
<p>所有类似数组的对象，都可以使用方括号运算符取出成员，所以一般情况下，都是使用下面的写法，而不使用item方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nodeItem = nodeList[index]</span></pre></td></tr></table></figure>

<h3 id="HTMLCollection接口"><a href="#HTMLCollection接口" class="headerlink" title="HTMLCollection接口"></a>HTMLCollection接口</h3><p>HTMLCollection接口与NodeList接口类似，也是节点的集合，但是集合成员都是Element节点。该接口都是动态集合，节点的变化会实时反映在集合中。document.links、docuement.forms、document.images等属性，返回的都是HTMLCollection接口对象。</p>
<p>部署了该接口的对象，具有length属性和数字索引，因此是一个类似于数组的对象。</p>
<p>item方法根据成员的位置参数（从0开始），返回该成员。如果取不到成员或数字索引不合法，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.images;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img1 = c.item(<span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于下面的写法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img1 = c[<span class="number">10</span>];</span></pre></td></tr></table></figure>

<p>namedItem方法根据成员的ID属性或name属性，返回该成员。如果没有对应的成员，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;form id="myForm"&gt;&lt;/form&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.forms.namedItem(<span class="string">"myForm"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于下面的写法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.forms[<span class="string">"myForm"</span>];</span></pre></td></tr></table></figure>

<p>由于item方法和namedItem方法，都可以用方括号运算符代替，所以建议一律使用方括号运算符。</p>
<h2 id="ParentNode接口，ChildNode接口"><a href="#ParentNode接口，ChildNode接口" class="headerlink" title="ParentNode接口，ChildNode接口"></a>ParentNode接口，ChildNode接口</h2><p>不同的节点除了继承Node接口以外，还会继承其他接口。ParentNode接口用于获取当前节点的Element子节点，ChildNode接口用于处理当前节点的子节点（包含但不限于Element子节点）。</p>
<h3 id="ParentNode接口"><a href="#ParentNode接口" class="headerlink" title="ParentNode接口"></a>ParentNode接口</h3><p>ParentNode接口用于获取Element子节点。Element节点、Document节点和DocumentFragment节点，部署了ParentNode接口。凡是这三类节点，都具有以下四个属性，用于获取Element子节点。</p>
<p><strong>（1）children</strong></p>
<p>children属性返回一个动态的HTMLCollection集合，由当前节点的所有Element子节点组成。</p>
<p>下面代码遍历指定节点的所有Element子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.children.length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; el.children.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>（2）firstElementChild</strong></p>
<p>firstElementChild属性返回当前节点的第一个Element子节点，如果不存在任何Element子节点，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.firstElementChild.nodeName</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// "HTML"</span></span></pre></td></tr></table></figure>

<p>上面代码中，document节点的第一个Element子节点是&lt;HTML&gt;。</p>
<p><strong>（3）lastElementChild</strong></p>
<p>lastElementChild属性返回当前节点的最后一个Element子节点，如果不存在任何Element子节点，则返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.lastElementChild.nodeName</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// "HTML"</span></span></pre></td></tr></table></figure>

<p>上面代码中，document节点的最后一个Element子节点是&lt;HTML&gt;。</p>
<p><strong>（4）childElementCount</strong></p>
<p>childElementCount属性返回当前节点的所有Element子节点的数目。</p>
<h3 id="ChildNode接口"><a href="#ChildNode接口" class="headerlink" title="ChildNode接口"></a>ChildNode接口</h3><p>ChildNode接口用于处理子节点（包含但不限于Element子节点）。Element节点、DocumentType节点和CharacterData接口，部署了ChildNode接口。凡是这三类节点（接口），都可以使用下面四个方法。但是现实的情况是，除了第一个remove方法，目前没有浏览器支持后面三个方法。</p>
<p><strong>（1）remove()</strong></p>
<p>remove方法用于移除当前节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">el.remove()</span></pre></td></tr></table></figure>

<p>上面方法在DOM中移除了el节点。注意，调用这个方法的节点，是被移除的节点本身，而不是它的父节点。</p>
<p><strong>（2）before()</strong></p>
<p>before方法用于在当前节点的前面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。</p>
<p><strong>（3）after()</strong></p>
<p>after方法用于在当前节点的后面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。</p>
<p><strong>（4）replaceWith()</strong></p>
<p>replaceWith方法使用参数指定的节点，替换当前节点。如果参数是节点对象，替换当前节点的就是该节点对象；如果参数是文本，替换当前节点的就是参数对应的文本节点。</p>
<h2 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h2><p><code>html</code>元素是网页的根元素，<code>document.documentElement</code>就指向这个元素。</p>
<p><strong>（1）clientWidth属性，clientHeight属性</strong></p>
<p>这两个属性返回视口（viewport）的大小，单位为像素。所谓“视口”，是指用户当前能够看见的那部分网页的大小</p>
<p><code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>，基本上与<code>window.innerWidth</code>和<code>window.innerHeight</code>同义。只有一个区别，前者不将滚动条计算在内（很显然，滚动条和工具栏会减小视口大小），而后者包括了滚动条的高度和宽度。</p>
<p><strong>（2）offsetWidth属性，offsetHeight属性</strong></p>
<p>这两个属性返回html元素的偏移宽度。</p>
<h3 id="dataset属性"><a href="#dataset属性" class="headerlink" title="dataset属性"></a>dataset属性</h3><p><code>dataset</code>属性用于操作HTML标签元素的<code>data-*</code>属性。下面是一个有<code>data-*</code>属性的<code>div</code>节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-id</span>=<span class="string">"myId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure>

<p>要读取<code>data-id</code>属性，可以从当前节点的<code>dataset.id</code>属性读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).dataset.id;</span></pre></td></tr></table></figure>

<p>要设置<code>data-id</code>属性，可以直接对<code>dataset.id</code>赋值。如果该属性不存在，将会被新建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>).dataset.id = <span class="string">'hello'</span>;</span></pre></td></tr></table></figure>

<p>删除一个<code>data-*</code>属性，可以直接使用<code>delete</code>命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).dataset.id;</span></pre></td></tr></table></figure>

<p>除了<code>dataset</code>属性，也可以用<code>getAttribute(&#39;data-foo&#39;)</code>、<code>removeAttribute(&#39;data-foo&#39;)</code>、<code>setAttribute(&#39;data-foo&#39;)</code>、<code>hasAttribute(&#39;data-foo&#39;)</code>等方法操作<code>data-*</code>属性。</p>
<p>需要注意的是，<code>dataset</code>属性使用骆驼拼写法表示属性名，这意味着<code>data-hello-world</code>会用<code>dataset.helloWorld</code>表示。而如果此时存在一个<code>data-helloWorld</code>属性，该属性将无法读取，也就是说，<code>data-*</code>属性本身只能使用连词号，不能使用骆驼拼写法。</p>
<h3 id="tabindex属性"><a href="#tabindex属性" class="headerlink" title="tabindex属性"></a>tabindex属性</h3><p><code>tabindex</code>属性用来指定，当前HTML元素节点是否被tab键遍历，以及遍历的优先级。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">document</span>.getElementById(<span class="string">"button1"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">b1.tabIndex = <span class="number">1</span>;</span></pre></td></tr></table></figure>

<p>如果 tabindex = -1 ，tab键跳过当前元素。</p>
<p>如果 tabindex = 0 ，表示tab键将遍历当前元素。如果一个元素没有设置tabindex，默认值就是0。</p>
<p>如果 tabindex 大于0，表示tab键优先遍历。值越大，就表示优先级越大。</p>
<h3 id="页面位置相关属性"><a href="#页面位置相关属性" class="headerlink" title="页面位置相关属性"></a>页面位置相关属性</h3><p><strong>（1）offsetParent属性、offsetTop属性和offsetLeft属性</strong></p>
<p>这三个属性提供Element对象在页面上的位置。</p>
<ul>
<li>offsetParent：当前HTML元素的最靠近的、并且CSS的position属性不等于static的父元素。</li>
<li>offsetTop：当前HTML元素左上角相对于offsetParent的垂直位移。</li>
<li>offsetLeft：当前HTML元素左上角相对于offsetParent的水平位移。</li>
</ul>
<p>如果Element对象的父对象都没有将position属性设置为非static的值（比如absolute或relative），则offsetParent属性指向body元素。另外，计算offsetTop和offsetLeft的时候，是从边框的左上角开始计算，即Element对象的border宽度不计入offsetTop和offsetLeft。</p>
<h3 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h3><p>style属性用来读写页面元素的行内CSS属性，详见本章《CSS操作》一节。</p>
<h3 id="Element对象的方法"><a href="#Element对象的方法" class="headerlink" title="Element对象的方法"></a>Element对象的方法</h3><p><strong>（1）选择子元素的方法</strong></p>
<p>Element对象也部署了document对象的4个选择子元素的方法，而且用法完全一样。</p>
<ul>
<li>querySelector方法</li>
<li>querySelectorAll方法</li>
<li>getElementsByTagName方法</li>
<li>getElementsByClassName方法</li>
</ul>
<p>上面四个方法只用于选择Element对象的子节点。因此，可以采用链式写法来选择子节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'header'</span>).getElementsByClassName(<span class="string">'a'</span>)</span></pre></td></tr></table></figure>

<p>各大浏览器对这四个方法都支持良好，IE的情况如下：IE 6开始支持getElementsByTagName，IE 8开始支持querySelector和querySelectorAll，IE 9开始支持getElementsByClassName。</p>
<p><strong>（2）elementFromPoint方法</strong></p>
<p>该方法用于选择在指定坐标的最上层的Element对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.elementFromPoint(<span class="number">50</span>,<span class="number">50</span>)</span></pre></td></tr></table></figure>

<p>上面代码了选中在(50,50)这个坐标的最上层的那个HTML元素。</p>
<p><strong>（3）HTML元素的属性相关方法</strong></p>
<ul>
<li>hasAttribute()：返回一个布尔值，表示Element对象是否有该属性。</li>
<li>getAttribute()</li>
<li>setAttribute()</li>
<li>removeAttribute()</li>
</ul>
<p><strong>（4）matchesSelector方法</strong></p>
<p>该方法返回一个布尔值，表示Element对象是否符合某个CSS选择器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'li'</span>).matchesSelector(<span class="string">'li:first-child'</span>)</span></pre></td></tr></table></figure>

<p>这个方法需要加上浏览器前缀，需要写成mozMatchesSelector()、webkitMatchesSelector()、oMatchesSelector()、msMatchesSelector()。</p>
<p><strong>（5）focus方法</strong></p>
<p>focus方法用于将当前页面的焦点，转移到指定元素上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'my-span'</span>).focus();</span></pre></td></tr></table></figure>

<h3 id="table元素"><a href="#table元素" class="headerlink" title="table元素"></a>table元素</h3><p>表格有一些特殊的DOM操作方法。</p>
<ul>
<li><strong>insertRow()</strong>：在指定位置插入一个新行（tr）。</li>
<li><strong>deleteRow()</strong>：在指定位置删除一行（tr）。</li>
<li><strong>insertCell()</strong>：在指定位置插入一个单元格（td）。</li>
<li><strong>deleteCell()</strong>：在指定位置删除一个单元格（td）。</li>
<li><strong>createCaption()</strong>：插入标题。</li>
<li><strong>deleteCaption()</strong>：删除标题。</li>
<li><strong>createTHead()</strong>：插入表头。</li>
<li><strong>deleteTHead()</strong>：删除表头。</li>
</ul>
<p>下面是使用JavaScript生成表格的一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">table.appendChild(tbody);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> rowcount = i + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  tbody.insertRow(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  tbody.rows[i].insertCell(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  tbody.rows[i].insertCell(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  tbody.rows[i].insertCell(<span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  tbody.rows[i].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Row '</span> + rowcount + <span class="string">', Cell 1'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  tbody.rows[i].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Row '</span> + rowcount + <span class="string">', Cell 2'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  tbody.rows[i].cells[<span class="number">2</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Row '</span> + rowcount + <span class="string">', Cell 3'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">table.createCaption();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">table.caption.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'A DOM-Generated Table'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span></pre></td></tr></table></figure>

<p>这些代码相当易读，其中需要注意的就是<code>insertRow</code>和<code>insertCell</code>方法，接受一个表示位置的参数（从0开始的整数）。</p>
<p><code>table</code>元素有以下属性：</p>
<ul>
<li><strong>caption</strong>：标题。</li>
<li><strong>tHead</strong>：表头。</li>
<li><strong>tFoot</strong>：表尾。</li>
<li><strong>rows</strong>：行元素对象，该属性只读。</li>
<li><strong>rows.cells</strong>：每一行的单元格对象，该属性只读。</li>
<li><strong>tBodies</strong>：表体，该属性只读。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Louis Lazaris, <a href="http://coding.smashingmagazine.com/2013/10/06/inside-the-box-with-vanilla-javascript/" target="_blank" rel="noopener">Thinking Inside The Box With Vanilla JavaScript</a></li>
<li>David Walsh, <a href="http://davidwalsh.name/classlist" target="_blank" rel="noopener">HTML5 classList API</a></li>
<li>Derek Johnson, <a href="http://html5doctor.com/the-classlist-api/" target="_blank" rel="noopener">The classList API</a></li>
<li>Mozilla Developer Network, <a href="http://davidwalsh.name/element-dataset" target="_blank" rel="noopener">element.dataset API</a></li>
<li>David Walsh, <a href="http://davidwalsh.name/element-dataset" target="_blank" rel="noopener">The element.dataset API</a> </li>
</ul>
	  

		<!-- 微信公众号关注 logo -->
		<div class="text-center">
			<img src="https://s2.ax1x.com/2019/11/27/Qp86qH.jpg">
			<span class="text-danger">全栈开发者微信公众号</span>
		</div>

	</div>

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2016/11/30/2016-11-30-document-text/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2016/11/30/2016-11-30-document/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

  <!-- share -->
  

	</div> 
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2016-11-30 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/JavaScript/">JavaScript<span>82</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Document/">Document<span>8</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
  <hr>

<!-- 淘宝广告 -->

	<div id="myCarousel" class="carousel slide" data-ride="carousel">

		<!-- 轮播（Carousel）指标 -->
		<ol class="carousel-indicators">
			

				
					<li data-target="#myCarousel" data-slide-to="0" class="active"></li>
				

			

				
					<li data-target="#myCarousel" data-slide-to="1"></li>
				

			

				
					<li data-target="#myCarousel" data-slide-to="2"></li>
				

			
		</ol>   

		<!-- 轮播（Carousel）项目 -->
		<div class="carousel-inner">
			

				
					<div class="item active">
						<a href="https://item.taobao.com/item.htm?spm=a2oq0.12575281.0.0.25911debHjpm1G&ft=t&id=573820740653" title="汽车用增高坐垫司机女士座垫主驾驶员单座矮个子加高加厚座椅" target="blank">
							<img src="https://gd3.alicdn.com/imgextra/i4/76548092/TB22E6hF_JYBeNjy1zeXXahzVXa_!!76548092.jpg_400x400.jpg" alt="驾考增高坐垫" class="nofancybox">
							<div class="carousel-caption">驾考增高坐垫</div>
						</a>
					</div>	
				

			

				
					<div class="item">
						<a href="https://item.taobao.com/item.htm?ft=t&id=575971596783" title="鼻器洗鼻壶家用瑜伽鼻腔冲洗器成人儿童洗鼻盐喷雾" target="blank">
							<img src="https://gd3.alicdn.com/imgextra/i3/76548092/TB2JQ5bs5AnBKNjSZFvXXaTKXXa_!!76548092.jpg" alt="鼻腔冲洗器" class="nofancybox">
							<div class="carousel-caption">鼻腔冲洗器</div>
						</a>
					</div>
				

			

				
					<div class="item">
						<a href="https://item.taobao.com/item.htm?ft=t&id=573821912854" title="10卷单排标价贴价格价钱打价签纸贴打码机器标价纸纸卷超市价签机" target="blank">
							<img src="https://gd4.alicdn.com/imgextra/i3/76548092/TB2yiAxFKuSBuNjy1XcXXcYjFXa_!!76548092.jpg" alt="标价贴" class="nofancybox">
							<div class="carousel-caption">标价贴</div>
						</a>
					</div>
				

			
		</div>

  </div> 


</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->


	</div>
  </div>

  <div class="container-narrow">
  <footer> 
<!-- 不蒜子统计 -->

    <span id="busuanzi_container_site_pv">
            本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv" style='display:none'>
            本站访客数 <span id="busuanzi_value_site_uv"> </span>人
    </span>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<span>
  &copy; 2020 JesseChiu
  
</span>

<span>
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/" target="_blank" rel="noopener">Freemind</a>.    
</span>
 </footer>
</div> <!-- container-narrow -->

  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

  
</body>

   </html>
