<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>浏览器环境概述 - Cease to struggle and you cease to live</title>
  <meta name="author" content="JesseChiu">
  
  <meta name="description" content="JavaScript代码嵌入网页的方法JavaScript代码只有嵌入网页，才能在用户浏览器网页时运行。
网页中嵌入JavaScript代码，主要有四种方法。

&amp;lt;script&amp;gt;标签：代码嵌入网页
&amp;lt;script&amp;gt;标签：加载外部脚本
事件属性：代码写入HTML元素的事件处理属">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="浏览器环境概述"/>
  <meta property="og:site_name" content="Cease to struggle and you cease to live"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Cease to struggle and you cease to live" type="application/atom+xml">
  
  
    <link href="/favicon.ico" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/spacelab.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <!-- analytics -->
  



</head>


 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Cease to struggle and you cease to live</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="">
			  <i class="fa fa-rss"></i>Rss
			</a>
		  </li>
		  
		  <li>
			<a href="/sitemap.xml" title="">
			  <i class="fa fa-sitemap"></i>Sitemap
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> 浏览器环境概述</h1>
		</div>		
	



<!-- 不蒜子统计 -->

        <span id="busuanzi_container_page_pv" style='display:none'>
              <i class="icon-smile icon"></i> 本文总阅读量: <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> 次
        </span>






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="JavaScript代码嵌入网页的方法"><a href="#JavaScript代码嵌入网页的方法" class="headerlink" title="JavaScript代码嵌入网页的方法"></a>JavaScript代码嵌入网页的方法</h2><p>JavaScript代码只有嵌入网页，才能在用户浏览器网页时运行。</p>
<p>网页中嵌入JavaScript代码，主要有四种方法。</p>
<ul>
<li><code>&lt;script&gt;</code>标签：代码嵌入网页</li>
<li><code>&lt;script&gt;</code>标签：加载外部脚本</li>
<li>事件属性：代码写入HTML元素的事件处理属性，比如<code>onclick</code>或者<code>onmouseover</code></li>
<li>URL协议：URL支持以<code>javascript:</code>协议的方式，执行JavaScript代码</li>
</ul>
<p>后两种方法用得很少，常用的是前两种方法。由于内容（HTML代码）和行为（JavaScript）代码应该分离，所以第一种方法应当谨慎使用。</p>
<h3 id="script标签：代码嵌入网页"><a href="#script标签：代码嵌入网页" class="headerlink" title="script标签：代码嵌入网页"></a>script标签：代码嵌入网页</h3><p>通过<code>&lt;script&gt;</code>标签，可以直接将JavaScript代码嵌入网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p><code>&lt;script&gt;</code>标签有一个<code>type</code>属性，用来指定脚本类型。对JavaScript脚本来说，<code>type</code>属性可以设为两种值。</p>
<ul>
<li><code>text/javascript</code>：这是默认值，也是历史上一贯设定的值。如果你省略<code>type</code>属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li>
<li><code>application/javascript</code>：对于较新的浏览器，建议设为这个值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>由于<code>&lt;script&gt;</code>标签默认就是JavaScript代码。所以，嵌入JavaScript脚本时，<code>type</code>属性也可以省略。</p>
<p>如果<code>type</code>属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在<code>&lt;script&gt;</code>标签之中嵌入任意的文本内容，然后加上一个浏览器不认识的<code>type</code>属性即可。</p>
<h3 id="script标签：加载外部脚本"><a href="#script标签：加载外部脚本" class="headerlink" title="script标签：加载外部脚本"></a>script标签：加载外部脚本</h3><p><code>&lt;script&gt;</code>标签也可以指定加载外部的脚本文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>如果脚本文件使用了非英语字符，还应该注明编码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>所加载的脚本必须是纯的HTML代码，不能有<code>HTML</code>代码和<code>&lt;script&gt;</code>标签。</p>
<p>加载外部脚本和直接添加代码块，这两种方法不能混用。下面代码的<code>console.log</code>语句直接被忽略。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"example.js"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>为了防止攻击者篡改外部脚本，<code>script</code>标签允许设置一个<code>integrity</code>属性，写入该外部脚本的Hash签名，用来验证脚本的一致性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/assets/application.js"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">"sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs="</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码中，<code>script</code>标签有一个<code>integrity</code>属性，指定了外部脚本<code>/assets/application.js</code>的SHA265签名。一旦有人改了这个脚本，导致SHA265签名不匹配，浏览器就会拒绝加载。</p>
<h3 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h3><p>某些HTML元素的事件属性（比如<code>onclick</code>和<code>onmouseover</code>），可以写入JavaScript代码。当指定事件发生时，就会调用这些代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面的事件属性代码只有一个语句。如果有多个语句，用分号分隔即可。</p>
<h3 id="URL协议"><a href="#URL协议" class="headerlink" title="URL协议"></a>URL协议</h3><p>URL支持<code>javascript:</code>协议，调用这个URL时，就会执行JavaScript代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('Hello')"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></pre></td></tr></table></figure>

<p>浏览器的地址栏也可以执行<code>javascipt:</code>协议。将<code>javascript:alert(&#39;Hello&#39;)</code>放入地址栏，按回车键，就会跳出提示框。</p>
<p>如果JavaScript代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都会消失。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:new Date().toLocaleTimeString();"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  What time is it?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码中，用户点击链接以后，会打开一个新文档，里面有当前时间。</p>
<p>如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascript:console.log(new Date().toLocaleTimeString())"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">What time is it?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/a&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码中，用户点击链接后，网页不会跳转，只会在控制台显示当前时间。</p>
<p><code>javascript:</code>协议的常见用途是书签脚本Bookmarklet。由于浏览器的书签保存的是一个网址，所以<code>javascript:</code>网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本最后返回<code>void 0</code>。</p>
<h2 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>浏览器加载JavaScript脚本，主要通过<code>&lt;script&gt;</code>标签完成。正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载HTML网页，一边开始解析</li>
<li>解析过程中，发现<code>&lt;script&gt;</code>标签</li>
<li>暂停解析，网页渲染的控制权转交给JavaScript引擎</li>
<li>如果<code>&lt;script&gt;</code>标签引用了外部脚本，就下载该脚本，否则就直接执行</li>
<li>执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页</li>
</ol>
<p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是JavaScript可以修改DOM（比如使用<code>document.write</code>方法），所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p>
<p>如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p>为了避免这种情况，较好的做法是将<code>&lt;script&gt;</code>标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。</p>
<p>如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码嵌入页面，而不是连接外部脚本文件，这样能缩短加载时间。</p>
<p>将脚本文件都放在网页尾部加载，还有一个好处。在DOM结构生成之前就调用DOM，JavaScript会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时DOM肯定已经生成了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.innerHTML);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码执行时会报错，因为此时<code>document.body</code>元素还未生成。</p>
<p>一种解决方法是设定<code>DOMContentLoaded</code>事件的回调函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">      <span class="string">'DOMContentLoaded'</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.innerHTML);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></pre></td></tr></table></figure>

<p>另一种解决方法是，使用<code>&lt;script&gt;</code>标签的<code>onload</code>属性。当<code>&lt;script&gt;</code>标签指定的外部脚本文件下载和解析完成，会触发一个load事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.min.js"</span> <span class="attr">onload</span>=<span class="string">"console.log(document.body.innerHTML)"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- 其他代码  --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.innerHTML);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr></table></figure>

<p>如果有多个<code>script</code>标签，比如下面这样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>浏览器会同时并行下载<code>a.js</code>和<code>b.js</code>，但是，执行时会保证先执行<code>a.js</code>，然后再执行<code>b.js</code>，即使后者先下载完成，也是如此。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p>
<p>Gecko和Webkit引擎在网页被阻塞后，会生成第二个线程解析文档，下载外部资源，但是不会修改DOM，网页还是处于阻塞状态。</p>
<p>解析和执行CSS，也会产生阻塞。Firefox会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本执行，等到样式表下载并解析完，再恢复执行。</p>
<p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般最多同时下载六个（IE11允许同时下载13个）。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p>
<h3 id="defer属性"><a href="#defer属性" class="headerlink" title="defer属性"></a>defer属性</h3><p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是加入<code>defer</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码中，只有等到DOM加载完成后，才会执行<code>a.js</code>和<code>b.js</code>。</p>
<p><code>defer</code>的运行流程如下。</p>
<ol>
<li>浏览器开始解析HTML网页</li>
<li>解析过程中，发现带有<code>defer</code>属性的<code>script</code>标签</li>
<li>浏览器继续往下解析HTML网页，同时并行下载<code>script</code>标签中的外部脚本</li>
<li>浏览器完成解析HTML网页，此时再执行下载的脚本</li>
</ol>
<p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的<code>script</code>标签，以及动态生成的<code>script</code>标签，<code>defer</code>属性不起作用。另外，使用<code>defer</code>加载的外部脚本不应该使用<code>document.write</code>方法。</p>
<h3 id="async属性"><a href="#async属性" class="headerlink" title="async属性"></a>async属性</h3><p>解决“阻塞效应”的另一个方法是加入<code>async</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p><code>async</code>属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>
<ol>
<li>浏览器开始解析HTML网页</li>
<li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签</li>
<li>浏览器继续往下解析HTML网页，同时并行下载<code>script</code>标签中的外部脚本</li>
<li>脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本</li>
<li>脚本执行完毕，浏览器恢复解析HTML网页</li>
</ol>
<p><code>async</code>属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用<code>async</code>属性的脚本文件中，不应该使用<code>document.write</code>方法。</p>
<p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>
<h3 id="脚本的动态加载"><a href="#脚本的动态加载" class="headerlink" title="脚本的动态加载"></a>脚本的动态加载</h3><p>除了静态的<code>script</code>标签，还可以动态生成<code>script</code>标签，然后加入页面，从而实现脚本的动态加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[<span class="string">'a.js'</span>, <span class="string">'b.js'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  script.src = src;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>这种方法的好处是，动态生成的<code>script</code>标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。</p>
<p>如果想避免这个问题，可以设置async属性为<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">[<span class="string">'a.js'</span>, <span class="string">'b.js'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  script.src = src;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  script.async = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面的代码依然不会阻塞页面渲染，而且可以保证<code>b.js</code>在<code>a.js</code>后面执行。不过需要注意的是，在这段代码后面加载的脚本文件，会因此都等待<code>b.js</code>执行完成后再执行。</p>
<p>我们可以把上面的写法，封装成一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> scripts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">url</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    script.async = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    script.src = url;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    scripts.parentNode.insertBefore(script, scripts);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  load(<span class="string">'//apis.google.com/js/plusone.js'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  load(<span class="string">'//platform.twitter.com/widgets.js'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  load(<span class="string">'//s.thirdpartywidget.com/widget.js'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;());</span></pre></td></tr></table></figure>

<p>上面代码中，<code>async</code>属性设为<code>true</code>，是因为加载的脚本没有互相依赖关系。而且，这样就不会造成堵塞。</p>
<p>此外，动态嵌入还有一个地方需要注意。动态嵌入必须等待CSS文件加载完成后，才会去下载外部脚本文件。静态加载就不存在这个问题，<code>script</code>标签指定的外部脚本文件，都是与CSS文件同时并发下载的。</p>
<h3 id="加载使用的协议"><a href="#加载使用的协议" class="headerlink" title="加载使用的协议"></a>加载使用的协议</h3><p>如果不指定协议，浏览器默认采用HTTP协议下载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>上面的<code>example.js</code>默认就是采用HTTP协议下载，如果要采用HTTPS协议下载，必需写明（假定服务器支持）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><p>浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称JavaScript引擎）。</p>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p>
<p>不同的浏览器有不同的渲染引擎。</p>
<ul>
<li>Firefox：Gecko引擎</li>
<li>Safari：WebKit引擎</li>
<li>Chrome：Blink引擎</li>
<li>IE: Trident引擎</li>
<li>Edge: EdgeHTML引擎</li>
</ul>
<p>渲染引擎处理网页，通常分成四个阶段。</p>
<ol>
<li>解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）</li>
<li>对象合成：将DOM和CSSOM合成一棵渲染树（render tree）</li>
<li>布局：计算出渲染树的布局（layout）</li>
<li>绘制：将渲染树绘制到屏幕</li>
</ol>
<p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的HTML代码还没下载完，但浏览器已经显示出内容了。</p>
<h3 id="重流和重绘"><a href="#重流和重绘" class="headerlink" title="重流和重绘"></a>重流和重绘</h3><p>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p>
<p>页面生成以后，脚本操作和样式表操作，都会触发重流（reflow）和重绘（repaint）。用户的互动，也会触发，比如设置了鼠标悬停（<code>a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p>
<p>重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p>
<p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p>
<p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的DOM元素，而以底层DOM元素的变动代替；再比如，重绘<code>table</code>布局和<code>flex</code>布局，开销都会比较大。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'foobar'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">foo.style.color = <span class="string">'blue'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">foo.style.marginTop = <span class="string">'30px'</span>;</span></pre></td></tr></table></figure>

<p>上面的代码只会导致一次重绘，因为浏览器会累积DOM变动，然后一次性执行。</p>
<p>下面是一些优化技巧。</p>
<ul>
<li>读取DOM或者写入DOM，尽量写在一起，不要混杂</li>
<li>缓存DOM信息</li>
<li>不要一项一项地改变样式，而是使用CSS class一次性改变样式</li>
<li>使用document fragment操作DOM</li>
<li>动画时使用absolute定位或fixed定位，这样可以减少对其他元素的影响</li>
<li>只在必要时才显示元素</li>
<li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流</li>
<li>使用虚拟DOM（virtual DOM）库</li>
</ul>
<p>下面是一个<code>window.requestAnimationFrame()</code>对比效果的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘代价高</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleHeight</span>(<span class="params">element</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> currentHeight = element.clientHeight;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  element.style.height = (currentHeight * <span class="number">2</span>) + <span class="string">'px'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">all_my_elements.forEach(doubleHeight);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘代价低</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleHeight</span>(<span class="params">element</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> currentHeight = element.clientHeight;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    element.style.height = (currentHeight * <span class="number">2</span>) + <span class="string">'px'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">all_my_elements.forEach(doubleHeight);</span></pre></td></tr></table></figure>

<h3 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h3><p>JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。</p>
<p>JavaScript是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p>
<p>为了提高运行速度，目前的浏览器都将JavaScript进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p>
<p>早期，浏览器内部对JavaScript的处理过程如下：</p>
<ol>
<li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>
<li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>
<li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>
<li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li>
</ol>
<p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。不同的浏览器有不同的编译策略。有的浏览器只编译最经常用到的部分，比如循环的部分；有的浏览器索性省略了字节码的翻译步骤，直接编译成机器码，比如chrome浏览器的V8引擎。</p>
<p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为JavaScript引擎。因为JavaScript运行时未必有字节码，所以JavaScript虚拟机并不完全基于字节码，而是部分基于源码，即只要有可能，就通过JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些JavaScript虚拟机：</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Chakra_(JScript_engine)" target="_blank" rel="noopener">Chakra</a>(Microsoft Internet Explorer)</li>
<li><a href="http://en.wikipedia.org/wiki/WebKit#JavaScriptCore" target="_blank" rel="noopener">Nitro/JavaScript Core</a> (Safari)</li>
<li><a href="http://dev.opera.com/articles/view/labs-carakan/" target="_blank" rel="noopener">Carakan</a> (Opera)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> (Firefox)</li>
<li><a href="http://en.wikipedia.org/wiki/V8_(JavaScript_engine)" target="_blank" rel="noopener">V8</a> (Chrome, Chromium)</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>John Dalziel, <a href="http://creativejs.com/2013/06/the-race-for-speed-part-2-how-javascript-compilers-work/" target="_blank" rel="noopener">The race for speed part 2: How JavaScript compilers work</a></li>
<li>Jake Archibald，<a href="http://www.html5rocks.com/en/tutorials/speed/script-loading/" target="_blank" rel="noopener">Deep dive into the murky waters of script loading</a></li>
<li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.setTimeout" target="_blank" rel="noopener">window.setTimeout</a></li>
<li>Remy Sharp, <a href="http://remysharp.com/2010/07/21/throttling-function-calls/" target="_blank" rel="noopener">Throttling function calls</a></li>
<li>Ayman Farhat, <a href="http://www.thecodeship.com/web-development/alternative-to-javascript-evil-setinterval/" target="_blank" rel="noopener">An alternative to Javascript’s evil setInterval</a></li>
<li>Ilya Grigorik, <a href="https://www.igvita.com/2014/05/20/script-injected-async-scripts-considered-harmful/" target="_blank" rel="noopener">Script-injected “async scripts” considered harmful</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2014/09/es6-promises-foundations.html" target="_blank" rel="noopener">ECMAScript 6 promises (1/2): foundations</a></li>
<li>Daniel Imms, <a href="http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noopener">async vs defer attributes</a></li>
<li>Craig Buckler, <a href="http://www.sitepoint.com/non-blocking-async-defer/" target="_blank" rel="noopener">Load Non-blocking JavaScript with HTML5 Async and Defer</a></li>
<li>Domenico De Felice, <a href="http://domenicodefelice.blogspot.sg/2015/08/how-browsers-work.html?t=2" target="_blank" rel="noopener">How browsers work</a></li>
</ul>
	  

		<!-- 微信公众号关注 logo -->
		<div class="text-center">
			<img src="https://s2.ax1x.com/2019/11/27/Qp86qH.jpg">
			<span class="text-danger">全栈开发者微信公众号</span>
		</div>

	</div>

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2017/03/04/2017-03-04-bom-history/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2017/03/04/2017-03-04-ajax-基础/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

  <!-- share -->
  

	</div> 
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2017-03-04 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/JavaScript/">JavaScript<span>82</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Bom/">Bom<span>10</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
  <hr>

<!-- 淘宝广告 -->

	<div id="myCarousel" class="carousel slide" data-ride="carousel">

		<!-- 轮播（Carousel）指标 -->
		<ol class="carousel-indicators">
			

				
					<li data-target="#myCarousel" data-slide-to="0" class="active"></li>
				

			

				
					<li data-target="#myCarousel" data-slide-to="1"></li>
				

			

				
					<li data-target="#myCarousel" data-slide-to="2"></li>
				

			
		</ol>   

		<!-- 轮播（Carousel）项目 -->
		<div class="carousel-inner">
			

				
					<div class="item active">
						<a href="https://item.taobao.com/item.htm?spm=a2oq0.12575281.0.0.25911debHjpm1G&ft=t&id=573820740653" title="汽车用增高坐垫司机女士座垫主驾驶员单座矮个子加高加厚座椅" target="blank">
							<img src="https://gd3.alicdn.com/imgextra/i4/76548092/TB22E6hF_JYBeNjy1zeXXahzVXa_!!76548092.jpg_400x400.jpg" alt="驾考增高坐垫" class="nofancybox">
							<div class="carousel-caption">驾考增高坐垫</div>
						</a>
					</div>	
				

			

				
					<div class="item">
						<a href="https://item.taobao.com/item.htm?ft=t&id=575971596783" title="鼻器洗鼻壶家用瑜伽鼻腔冲洗器成人儿童洗鼻盐喷雾" target="blank">
							<img src="https://gd3.alicdn.com/imgextra/i3/76548092/TB2JQ5bs5AnBKNjSZFvXXaTKXXa_!!76548092.jpg" alt="鼻腔冲洗器" class="nofancybox">
							<div class="carousel-caption">鼻腔冲洗器</div>
						</a>
					</div>
				

			

				
					<div class="item">
						<a href="https://item.taobao.com/item.htm?ft=t&id=573821912854" title="10卷单排标价贴价格价钱打价签纸贴打码机器标价纸纸卷超市价签机" target="blank">
							<img src="https://gd4.alicdn.com/imgextra/i3/76548092/TB2yiAxFKuSBuNjy1XcXXcYjFXa_!!76548092.jpg" alt="标价贴" class="nofancybox">
							<div class="carousel-caption">标价贴</div>
						</a>
					</div>
				

			
		</div>

  </div> 


</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->


	</div>
  </div>

  <div class="container-narrow">
  <footer> 
<!-- 不蒜子统计 -->

    <span id="busuanzi_container_site_pv">
            本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv" style='display:none'>
            本站访客数 <span id="busuanzi_value_site_uv"> </span>人
    </span>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<span>
  &copy; 2020 JesseChiu
  
</span>

<span>
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/" target="_blank" rel="noopener">Freemind</a>.    
</span>
 </footer>
</div> <!-- container-narrow -->

  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

  
</body>

   </html>
