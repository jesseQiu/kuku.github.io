<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Cease to struggle and you cease to live</title>
  <meta name="author" content="JesseChiu">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Cease to struggle and you cease to live"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Cease to struggle and you cease to live" type="application/atom+xml">
  
  
    <link href="/favicon.ico" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/spacelab.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <!-- analytics -->
  



</head>


 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Cease to struggle and you cease to live</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="">
			  <i class="fa fa-rss"></i>Rss
			</a>
		  </li>
		  
		  <li>
			<a href="/sitemap.xml" title="">
			  <i class="fa fa-sitemap"></i>Sitemap
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">Cease to struggle and you cease to live</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Keep on going never give up.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
            
		
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2020-11-10 </div>
			<div class="article-title"><a href="/2020/11/10/2020-11-10-docker.starting/" >Docker</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p>
</blockquote>
<h2 id="1-Docker的应用场景"><a href="#1-Docker的应用场景" class="headerlink" title="1. Docker的应用场景"></a>1. Docker的应用场景</h2><ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h2 id="2-Docker-的优点"><a href="#2-Docker-的优点" class="headerlink" title="2. Docker 的优点"></a>2. Docker 的优点</h2><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<ol>
<li><p>快速，一致地交付您的应用程序<br>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。<br>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：<br>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。<br>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。<br>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。<br>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</p>
</li>
<li><p>响应式部署和扩展<br>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。<br>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p>
</li>
<li><p>在同一硬件上运行更多工作负载<br>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p>
</li>
</ol>
<h2 id="3-镜像相关命令"><a href="#3-镜像相关命令" class="headerlink" title="3. 镜像相关命令"></a>3. 镜像相关命令</h2><h3 id="3-1-更新镜像"><a href="#3-1-更新镜像" class="headerlink" title="3.1 更新镜像"></a>3.1 更新镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// 更新镜像之前，我们需要使用镜像来创建一个容器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu:15.10 /bin/bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">// 在运行的容器内使用 apt-get update 命令进行更新</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">apt-get update </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">// 退出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">// 是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">// -m: 提交的描述信息</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">// -a: 指定镜像作者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">// e218edb10161：容器 ID</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">// runoob/ubuntu:v2: 指定要创建的目标镜像名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">docker commit -m=<span class="string">"has update"</span> -a=<span class="string">"runoob"</span> e218edb10161 runoob/ubuntu:v2</span></pre></td></tr></table></figure>

<h3 id="3-2-构建镜像"><a href="#3-2-构建镜像" class="headerlink" title="3.2 构建镜像"></a>3.2 <a href="https://www.runoob.com/docker/docker-image-usage.html" target="_blank" rel="noopener">构建镜像</a></h3><h3 id="3-3-其它"><a href="#3-3-其它" class="headerlink" title="3.3 其它"></a>3.3 其它</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// 列出镜像列表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker images</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">// 获取一个新镜像</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">docker pull xxx:version</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">// 查找镜像</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">docker search xxxx</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">// 导出镜像文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">// 将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">docker save -o jesse.centos.tar centos</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">// 导入镜像文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">// --input , -i : 指定导入的文件，代替 STDIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">docker load -i jesse.centos.tar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">// 删除镜像</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">docker rmi xxxx</span></pre></td></tr></table></figure>



<h2 id="4-容器相关命令"><a href="#4-容器相关命令" class="headerlink" title="4. 容器相关命令"></a>4. 容器相关命令</h2><h3 id="4-1-启动容器"><a href="#4-1-启动容器" class="headerlink" title="4.1 启动容器"></a>4.1 启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// -t: 在新容器内指定一个伪终端或终端</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">// -i: 允许你对容器内的标准输入 (STDIN) 进行交互</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">// /bin/<span class="built_in">echo</span> <span class="string">"Hello World"</span>: 在启动的容器里执行的命令</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">docker run -i -t xxxx /bin/<span class="built_in">echo</span> <span class="string">"Hello World"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">// -d: 后台模式启动</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">// 注：加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker <span class="built_in">exec</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">docker run -d xxx</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">// 运行容器，并把当前的某个目录挂载到容器指定目录中</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">// -v <span class="variable">$PWD</span>/myapp:/usr/src/myapp: 将主机中当前目录下的 myapp 挂载到容器的 /usr/src/myapp。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">// -w /usr/src/myapp: 指定容器的 /usr/src/myapp 目录为工作目录。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">// python helloworld.py: 使用容器的 python 命令来执行工作目录中的 helloworld.py 文件。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">docker run  -v <span class="variable">$PWD</span>/myapp:/usr/src/myapp  -w /usr/src/myapp python:3.5 python helloworld.py</span></pre></td></tr></table></figure>

<h3 id="4-2-启动已停止运行的容器"><a href="#4-2-启动已停止运行的容器" class="headerlink" title="4.2 启动已停止运行的容器"></a>4.2 启动已停止运行的容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">docker ps -a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker start &lt;容器 ID&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">// 或者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器 ID&gt;</span></pre></td></tr></table></figure>

<h3 id="4-3-停止一个容器"><a href="#4-3-停止一个容器" class="headerlink" title="4.3 停止一个容器"></a>4.3 停止一个容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt;</span></pre></td></tr></table></figure>

<h3 id="4-4-进入容器"><a href="#4-4-进入容器" class="headerlink" title="4.4 进入容器"></a>4.4 进入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// docker attach: 如果运行 <span class="built_in">exit</span> 容易导致停止容器运行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker attach &lt;容器 ID&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">// 或者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">// docker <span class="built_in">exec</span>:推荐大家使用 docker <span class="built_in">exec</span> 命令，因为此退出容器终端，不会导致容器的停止。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器 ID&gt; /bin/bash</span></pre></td></tr></table></figure>


<h3 id="4-5-查看容器-Docker-底层信息"><a href="#4-5-查看容器-Docker-底层信息" class="headerlink" title="4.5 查看容器 Docker 底层信息"></a>4.5 查看容器 Docker 底层信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器 ID&gt;</span></pre></td></tr></table></figure>

<h3 id="4-6-查看容器日志"><a href="#4-6-查看容器日志" class="headerlink" title="4.6 查看容器日志"></a>4.6 查看容器日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// -f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker logs -f &lt;容器 ID&gt;</span></pre></td></tr></table></figure>

<h3 id="4-7-容器互联"><a href="#4-7-容器互联" class="headerlink" title="4.7 容器互联"></a>4.7 <a href="https://www.runoob.com/docker/docker-container-connection.html" target="_blank" rel="noopener">容器互联</a></h3><h3 id="4-8-其它"><a href="#4-8-其它" class="headerlink" title="4.8 其它"></a>4.8 其它</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// 导出容器快照</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> &lt;容器 ID&gt; &gt; ubuntu.tar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">// 导入容器快照</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">// 下面是将快照文件 ubuntu.tar 导入到镜像 <span class="built_in">test</span>/ubuntu:v1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">cat docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">// 也可以通过指定 URL 或者某个目录来导入</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">// 从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">docker import  my_ubuntu_v3.tar runoob/ubuntu:v4 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">// 删除容器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">docker rm -f &lt;容器 ID&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">// 容器内部的 5000 端口映射到我们本地主机的 5000 端口上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">// -P :是容器内部端口随机映射到主机的高端口。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">// -p :是容器内部端口绑定到指定的主机端口。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">// 查看端口映射</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">docker port &lt;容器 ID&gt;</span></pre></td></tr></table></figure>

<h2 id="5-本地和容器之间内容拷贝"><a href="#5-本地和容器之间内容拷贝" class="headerlink" title="5. 本地和容器之间内容拷贝"></a>5. 本地和容器之间内容拷贝</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">// 将主机 /www/runoob 目录 拷贝到容器 96f7f14e99ab的/www 目录下</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">// 将主机 /www/runoob 目录 拷贝到容器 96f7f14e99ab中，目录重命名为 www</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">// 将容器 96f7f14e99a b的 /www 目录拷贝到主机的 /tmp 目录中</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener">docker 官网</a></li>
<li><a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">docker github</a></li>
<li><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">docker 菜鸟教程</a></li>
<li><a href="https://www.imooc.com/learn/867" target="_blank" rel="noopener">imooc Docker入门</a></li>
<li><a href="https://www.imooc.com/learn/824" target="_blank" rel="noopener">imooc 第一个docker化的java应用</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2020-11-09 </div>
			<div class="article-title"><a href="/2020/11/09/2020-11-09-android.sparseArray.arrayMap/" >性能优化:使用SparseArray和ArrayMap代替HashMap</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>在 Android 开发时，我们使用的大部分都是Java的api，比如HashMap这个api，使用率非常高，但是对于Android这种对内存非常敏感的移动平台，很多时候使用一些java的api并不能达到更好的性能，相反反而更消耗内存，所以针对Android这种移动平台，也推出了更符合自己的api，比如SparseArray、ArrayMap用来代替HashMap在有些情况下能带来更好的性能提升。</p>
<p>介绍它们之前先来介绍一下HashMap的内部存储结构，就明白为什么推荐使用SparseArray和ArrayMap</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h2><p>HashMap内部是使用一个默认容量为16的数组来存储数据的，而数组中每一个元素却又是一个链表的头结点，所以，更准确的来说，HashMap内部存储结构是使用哈希表的拉链结构（数组+链表），如图：<br>这种存储数据的方法叫做拉链法<br><img src="https://img-blog.csdn.net/20150820130200565" alt="这里写图片描述"><br>且每一个结点都是Entry类型，那么Entry是什么呢？我们来看看HashMap中Entry的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">final K key;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">V value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">final int hash;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">HashMapEntry&lt;K, V&gt; next;</span></pre></td></tr></table></figure>

<p>从中我们得知Entry存储的内容有key、value、hash值、和next下一个Entry，那么，这些Entry数据是按什么规则进行存储的呢？就是通过计算元素key的hash值，然后对HashMap中数组长度取余得到该元素存储的位置，计算公式为hash(key)%len，比如：假设hash(14)=14,hash(30)=30,hash(46)=46，我们分别对len取余，得到<br>hash(14)%16=14，hash(30)%16=14，hash(46)%16=14，所以key为14、30、46的这三个元素存储在数组下标为14的位置，如：<br><img src="https://img-blog.csdn.net/20150820133048242" alt="这里写图片描述"><br>从中可以看出，如果有多个元素key的hash值相同的话，后一个元素并不会覆盖上一个元素，而是采取链表的方式，把之后加进来的元素加入链表末尾，从而解决了hash冲突的问题，由此我们知道HashMap中处理hash冲突的方法是链地址法，在此补充一个知识点，处理hash冲突的方法有以下几种：</p>
<ol>
<li>开放地址法</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ol>
<p>讲到这里，重点来了，我们知道HashMap中默认的存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap对象时，即使里面没有任何元素，也要分别一块内存空间给它，而且，我们再不断的向HashMap里put数据时，当达到一定的容量限制时（这个容量满足这样的一个关系时候将会扩容：HashMap中的数据量&gt;容量*加载因子，而HashMap中默认的加载因子是0.75），HashMap的空间将会扩大，而且扩大后新的空间一定是原来的2倍，我们可以看put()方法中有这样的一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int newCapacity &#x3D; oldCapacity * 2;</span></pre></td></tr></table></figure>

<p>所以，重点就是这个，只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费，而且HashMap获取数据是通过遍历Entry[]数组来得到对应的元素，在数据量很大时候会比较慢，所以在Android中，HashMap是比较费内存的，我们在一些情况下可以使用SparseArray和ArrayMap来代替HashMap。</p>
<h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a><strong>SparseArray</strong></h2><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">private int[] mKeys;    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">private Object[] mValues;</span></pre></td></tr></table></figure>


<p>我们可以看到，SparseArray只能存储key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法，我们可以看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public void put(int key, E value) &#123;        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);        ...        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    public E get(int key, E valueIfKeyNotFound) &#123;        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);        ...        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr></table></figure>


<p>也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从小到大的顺序排列好，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。<br>而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public void put(int key, E value)</span></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public void remove(int key)</span></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public void delete(int key)</span></pre></td></tr></table></figure>

<p>其实remove内部还是通过调用delete来删除数据的</p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public E get(int key)</span></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public E get(int key, E valueIfKeyNotFound)</span></pre></td></tr></table></figure>

<p>该方法可设置如果key不存在的情况下默认返回的value</p>
<h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>在此之外，SparseArray还提供了两个特有方法，更方便数据的查询：<br>获取对应的key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public int keyAt(int index)</span></pre></td></tr></table></figure>


<p>获取对应的value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public E valueAt(int index)</span></pre></td></tr></table></figure>

<h3 id="SparseArray应用场景："><a href="#SparseArray应用场景：" class="headerlink" title="SparseArray应用场景："></a><strong>SparseArray应用场景：</strong></h3><p>虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。</p>
<p>满足下面两个条件我们可以使用SparseArray代替HashMap：</p>
<ul>
<li>数据量不大，最好在千级以内</li>
<li>key必须为int类型，这中情况下的HashMap可以用SparseArray代替：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">用SparseArray代替:SparseArray&lt;Object&gt; array &#x3D; new SparseArray&lt;&gt;();</span></pre></td></tr></table></figure>


<h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a><strong>ArrayMap</strong></h2><p>这个api的资料在网上可以说几乎没有，然并卵，只能看文档了<br>ArrayMap是一个&lt;<strong>key,value</strong>&gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。</p>
<h3 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public V put(K key, V value)</span></pre></td></tr></table></figure>

<h3 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public V get(Object key)</span></pre></td></tr></table></figure>

<h3 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public V remove(Object key)</span></pre></td></tr></table></figure>


<h3 id="特有方法-1"><a href="#特有方法-1" class="headerlink" title="特有方法"></a>特有方法</h3><p>它和SparseArray一样同样也有两个更方便的获取数据方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public K keyAt(int index)public V valueAt(int index)</span></pre></td></tr></table></figure>

<h3 id="ArrayMap应用场景"><a href="#ArrayMap应用场景" class="headerlink" title="ArrayMap应用场景"></a><strong>ArrayMap应用场景</strong></h3><ul>
<li>数据量不大，最好在千级以内</li>
<li>数据结构类型为Map类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;Key, Value&gt; arrayMap &#x3D; new ArrayMap&lt;&gt;();</span></pre></td></tr></table></figure>

<p>【注】：如果我们要兼容aip19以下版本的话，那么导入的包需要为v4包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import android.support.v4.util.ArrayMap;</span></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>SparseArray和ArrayMap都差不多，使用哪个呢？<br>假设数据量都在千级以内的情况下：</p>
<blockquote>
<p>1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用</p>
<p>2、如果key类型为其它的类型，则使用ArrayMap</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/aptentity/article/details/65449959" target="_blank" rel="noopener">性能优化：使用SparseArray和ArrayMap代替HashMap</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-12-10 </div>
			<div class="article-title"><a href="/2019/12/10/2019-12-10-android-compile-target-min-sdkversion/" >CompileSdkVersion、TargetSdkVersion、MinSdkVersion</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="CompileSdkVersion"><a href="#CompileSdkVersion" class="headerlink" title="CompileSdkVersion"></a>CompileSdkVersion</h2><p>*定义应用程序编译选择哪个 Android SDK版本，通常 compileSDKVersion 属性值被设置为最新的API版本，例如：25，改变 compileSDKVersion 的属性值不会影响 Android 系统运行行为，比如说，将属性值设置为 25，targetSdkVersion 属性值为 23，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">compileSdkVersion 25</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">buildToolsVersion "25.0.2"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    applicationId "cn.teachcourse.demos"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    minSdkVersion 11</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    targetSdkVersion 23</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    versionCode 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    versionName "1.0"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>开发的应用程序在 Android 7.0 系统运行，不会以 Android 7.0 新增的行为运行，<strong>决定 Android 系统行为的仍然是 targetSDKVersion</strong>，那么 compileSDKVersion 有什么用呢？选择最新的 API 版本，在编译的时候检查代码的错误和警告，提示开发者修改和优化，因为通常在 Android 项目中会引入第三方的支持库，支持库使用了 23.1.1 版本，compileSdkVersion 的属性值至少为 23.0.0，新版本的支持库的发布紧跟着对应的Android系统平台，能够更好的兼容。</p>
<h2 id="MinSdkVersion"><a href="#MinSdkVersion" class="headerlink" title="MinSdkVersion"></a>MinSdkVersion</h2><p>定义应用程序支持的最低 API 版本，最低版本设置为 API 11，目标版本设置为 API 24，那么应用程序调用使用 API 14 提供的方法时，Android Studio 或 Eclipse 开发工具将提醒开发者引用一个未定义的方法，使用该方法需要将 minSdkVersion 设置为 API 14 以上，如下图：</p>
<p><img src="https://blog.csdn.net/u012345683/article/details/81286989" alt=""></p>
<p>造成的结果大于或等于 Android 4.0(API 14) 的系统可以正常执行，小于 Android 4.0 的系统将在运行时尝试访问不可用的 API 时发生崩溃。</p>
<h2 id="TargetSdkVersion"><a href="#TargetSdkVersion" class="headerlink" title="TargetSdkVersion"></a>TargetSdkVersion</h2><p>目标软件开发版本，在创建每一个 Android 项目的时候都需要选择 targetSdkVersion 和 minSdkVersion，一个 targetSdkVersion 的属性值表示创建的 Android 项目使用哪个 API 版本，一个 API 版本使用一个整型数字表示，API 的全称是 Application Programming Interface，即应用程序编程接口，API 19 对应的编程接口和 API 23 定义的编程接口存在差别，因为使用整型数字表示 targetSdkVersion 的属性值，容易记忆和便于比较它们之间的大小，高版本 API 编程接口可以兼容低版本 API 编程接口，反之则不行。</p>
<p>需要区别 Android 7.0 和 API 24 之间的关系，Android 7.0 定义的手机系统的版本，该系统的版本对外开放的应用程序接口被定义为 API 24，如果开发者想要在开发的 APP 中使用 Android 7.0 系统提供的功能，这些功能包括：多窗口支持、通知显示变更、JIT/AOT 编译、快速的应用安装路径等等，那么新手在创建的 Android 项目的时候就需要选择 API 24 的应用程序接口。</p>
<p>简单来说就代表着你的 App 能够适配的系统版本，意味着你的 App 在这个版本的手机上做了充分的 前向 兼容性处理和实际测试。其实我们写代码时都是经常干这么一件事，就是 <code>if(Build.VERSION.SDK_INT &gt;= 23) { … }</code> ，这就是兼容性处理最典型的一个例子。如果你的 target 设置得越高，其实调用系统提供的 API 时，所得到的处理也是不一样的，甚至有些新的 API 是只有新的系统才有的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样一来我们就可以知道，版本号的大小关系就是：compileSdkVersion &gt; targetSdkVersion &gt; minSdkVersion</p>
<ul>
<li>compileSdkVersion: 代表着编译的时候，会采用该 API 的规范进行代码检查和警告，但是并不会编译进 APK 中</li>
<li>targetSdkVersion: 代表着目标版本，在编译的时候会将该版本的 API 编译进 APK 中</li>
<li>minSdkVersion: 代表着最低版本，在编译的时候<strong>兼容</strong>到该参数指定最低版本 API</li>
</ul>
<p>安卓中的兼容其实是，各个 API 接口中通过判断系统的版本来兼容的，比如最常见的 View 的创建过程，就是在创建之前判断当前运行的安卓系统版本是多少，然后调用对应的 API 接口进行创建。targetSdkVersion，minSdkVersion 的版本问题就迎刃而解了，说明打包的时候将最高版本的 API 接口到最低版本之间的 API 打包进 APK 中，如果安装到范围之外的安卓系统中，那么运行程序肯定就是找不到方法的错误出现。而如果 targetSdkVersion 版本低于 23，但是装在了 6.0 以上的系统中的话，那么动态权限申请的 API 没有打包进 APK 中，所以自然还是走低版本的权限流程，不需要动态申请就可以获得权限了。安卓系统至于为什么会兼容低于自己系统的 targetSdkVersion 版本，也是因为源码里面对 API 接口调用做了版本判断，用于向下兼容。</p>
<p>Android6.0普通权限normal permission 和 危险权限dangerous permission<br>Normal Permission：写在xml文件里，那么App安装时就会默认获得这些权限，即使是在Android6.0系统的手机上，用户也无法在安装后动态取消这些normal权限，这和以前的权限系统是一样的，不变。</p>
<h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p>Dangerous Permission：还是得写在 xml 文件里，但是 App 安装时具体如果执行授权分以下几种情况：<br>1、targetSDKVersion &lt; 23 &amp; API(手机系统) &lt; 6.0 ：安装时默认获得权限，且用户无法在安装 App 之后取消权限。<br>2、targetSDKVersion &lt; 23 &amp; API(手机系统) &gt;= 6.0 ：安装时默认获得权限，但是用户可以在安装 App 完成后动态取消授权（ 取消时手机会弹出提醒，告诉用户这个是为旧版手机打造的应用，让用户谨慎操作 ）。<br>3、targetSDKVersion &gt;= 23 &amp; API(手机系统) &lt; 6.0 ：安装时默认获得权限，且用户无法在安装 App 之后取消权限<br>4、targetSDKVersion &gt;= 23 &amp; API(手机系统) &gt;= 6.0 ：安装时不会获得权限，可以在运行时向用户申请权限。用户授权以后仍然可以在设置界面中取消授权，用户主动在设置界面取消后，在 app 运行过程中可能会出现 crash。</p>
<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p>现在有一个类 Icon，这个类是在 api 版本 23 加入到 android frame 源码中的，如果 compileSdkVersion=28，targetSdkVersion=23 ，minSdkVersion=16 的话，编译是不会有任何问题的，因为我的 targetSdkVersion 版本就包含了 Icon 这个类，如果我将其设置为 22 就会报错，说找不到这个类，因为 android.jar 架包内不存在这个类，如果我将 targetSdkVersion 设置为 23，并且打包出来的 apk 安装到 5.0 的手机上的时候，会发现程序闪退，之所这样是因为，android.jar 只参与编译（frame层代码是手机自带的，不会从外部打包进 apk 的），并不会打包进 apk，这样 apk 在调用 Ico 类的时候，使用的是安卓手机自带的 frame 层代码，Icon 在 api23 引入，5.0 的手机自然就没有，程序自然就会 crash 掉。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u012345683/article/details/81286989" target="_blank" rel="noopener">compileSdkVersion、targetSdkVersion、minSdkVersion 三者的关系</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-12-05 </div>
			<div class="article-title"><a href="/2019/12/05/2019-12-05-android-rxjava/" >Android-rxjava</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="Android-Studio-rxjava-环境配置"><a href="#Android-Studio-rxjava-环境配置" class="headerlink" title="Android Studio rxjava 环境配置"></a>Android Studio rxjava 环境配置</h2><p>由于 Android 的仓库有两个，默认创建工程中的 jcenter 和 google 并没有包含 rxjava 和 rxandroid 的库。所以需要在工程目录下的 <code>build.grade</code> 中添加下面的语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    repositories &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        google()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        jcenter()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        maven &#123; url <span class="string">"https://jitpack.io"</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        mavenCentral()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="配置支持-Lambda-表达式"><a href="#配置支持-Lambda-表达式" class="headerlink" title="配置支持 Lambda 表达式"></a>配置支持 Lambda 表达式</h2><ul>
<li>Android Studio 3.x 默认支持</li>
<li>在 app 文件夹下的 <code>build.grade</code> 文件中添加下面语句<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">android &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    // ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    compileOptions &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-11-14 </div>
			<div class="article-title"><a href="/2019/11/14/2019-11-14-java-NIO/" >NIO</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>简介：网络编程 -&gt; RPC 的 “基石”。众所周知，网络编程有三种方式：BIO、NIO、AIO。本课程通过对 BIO/NIO 两种编程模型对比的形式，引入 NIO 的优势。后对 NIO 核心类进行梳理、分析。最后通过动手实践，完成一个基于 NIO 的多人聊天室功能。通过动手实践，来加深对 NIO 原理的理解，并发现NIO的不足之处，培养辩证的看待和使用 NIO 解决问题的能力。</p>
</blockquote>
<ul>
<li><p>NIO: Non-blocking I/O || New I/O</p>
</li>
<li><p>JDK 1.4</p>
</li>
<li><p>用于高并发场景</p>
</li>
<li><p>Channel,Buffer,Selector</p>
</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.imooc.com/learn/1118" target="_blank" rel="noopener">解锁网络编程之NIO的前世今生</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-11-06 </div>
			<div class="article-title"><a href="/2019/11/06/2019-11-06-flutter/" >Flutter</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>Flutter 是谷歌的移动 UI 框架 ，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。 Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的。它也是构建未来的 Google Fuchsia(/ˈfjuːʃə/ ) 应用的主要方式。<br>Flutter 组件采用现代响应式框架构建，这是从 React 中获得的灵感，中心思想是用组件(widget)构建你的UI。 组件描述了在给定其当前配置和状态时他们显示的样子。当组件状态改变，组件会重构它的描述(description)，Flutter 会对比之前的描述， 以确定底层渲染树从当前状态转换到下一个状态所需要的最小更改。</p>
</blockquote>
<ul>
<li>Google 推出一款跨平台的 UI 套件</li>
<li>Linux，Android，IOS，Web</li>
<li>原生的用户界面</li>
<li>开源，免费</li>
<li>渲染技术上使用了自主开发的(GDI)</li>
<li>120fps 超高技术</li>
<li>性能优于 Codova，RN</li>
<li>以 Dart 语言编程</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://flutter.dev/" target="_blank" rel="noopener">flutter</a></li>
<li><a href="https://github.com/Solido/awesome-flutter" target="_blank" rel="noopener">awesome-flutter github</a></li>
<li><a href="https://www.imooc.com/learn/1090" target="_blank" rel="noopener">Flutter入门与案例实战</a></li>
<li><a href="https://baike.baidu.com/item/Fuchsia/19900570?fr=aladdin" target="_blank" rel="noopener">Fuchsia</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-10-03 </div>
			<div class="article-title"><a href="/2019/10/03/2019-10-02.car/" >Car Parameters</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="汽车参数"><a href="#汽车参数" class="headerlink" title="汽车参数"></a>汽车参数</h2><h3 id="汽车风阻系数"><a href="#汽车风阻系数" class="headerlink" title="汽车风阻系数"></a>汽车风阻系数</h3><p>汽车在行驶中由于受到空气的作用，围绕着汽车重心同时产生纵向、侧向和垂直等 3 个方向的空气动力量，对高速行驶的汽车都会产生不同的影响，其中纵向空气动力量最大，大约占整体空气作用力的 80% 以上，因此，将汽车直线行驶时受到的空气作用力在行驶方向上的分力称为空气阻力。<br>风阻系数 Cd 是衡量一辆汽车受空气阻力影响大小的一个标准。风阻系数越小，说明它受空气阻力影响越小，反之亦然，因此说风阻系数越小越好。<br>一般来讲，我们在马路上看到的大多数轿车的风阻系数在 0.28—0.4 间，流线性较好的汽车如跑车等，其风阻系数可达到 0.25 左右，一些赛车可达到 0.15 左右。</p>
<ul>
<li><a href="https://v.qq.com/x/page/i03811obhiv.html" target="_blank" rel="noopener">熊先生三分钟讲懂“风阻系数”</a></li>
</ul>
<h3 id="碰撞预警"><a href="#碰撞预警" class="headerlink" title="碰撞预警"></a>碰撞预警</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=384243644986707637&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">碰撞预警</a></li>
</ul>
<h3 id="并线辅助"><a href="#并线辅助" class="headerlink" title="并线辅助"></a>并线辅助</h3><ul>
<li><a href="https://v.qq.com/x/page/e0198o98h2t.html" target="_blank" rel="noopener">并线辅助</a></li>
</ul>
<h3 id="车道偏离预警"><a href="#车道偏离预警" class="headerlink" title="车道偏离预警"></a>车道偏离预警</h3><ul>
<li><a href="https://v.qq.com/x/page/w05499mtfo8.html" target="_blank" rel="noopener">车道偏离预警</a></li>
</ul>
<h3 id="发动机电子防盗"><a href="#发动机电子防盗" class="headerlink" title="发动机电子防盗"></a>发动机电子防盗</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=13155749160207676870&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">发动机电子防盗</a></li>
</ul>
<h3 id="胎压监测系统"><a href="#胎压监测系统" class="headerlink" title="胎压监测系统"></a>胎压监测系统</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=775049808605790892&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">胎压监测系统</a></li>
</ul>
<h3 id="发动机自动启停系统"><a href="#发动机自动启停系统" class="headerlink" title="发动机自动启停系统"></a>发动机自动启停系统</h3><ul>
<li><a href="http://www.iqiyi.com/w_19s1sik3od.html" target="_blank" rel="noopener">发动机自动启停系统</a></li>
</ul>
<h3 id="ABS-防抱死系统-antilock-brake-system"><a href="#ABS-防抱死系统-antilock-brake-system" class="headerlink" title="ABS 防抱死系统(antilock brake system)"></a>ABS 防抱死系统(antilock brake system)</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=3247817090386799909&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">ABS 防抱死系统</a></li>
</ul>
<h3 id="EBD-自动力分配-Electronic-Brake-force-Distribution"><a href="#EBD-自动力分配-Electronic-Brake-force-Distribution" class="headerlink" title="EBD 自动力分配(Electronic Brake force Distribution)"></a>EBD 自动力分配(Electronic Brake force Distribution)</h3><ul>
<li><a href="https://www.iqiyi.com/w_19rqq6pq01.html" target="_blank" rel="noopener">综合解读EBD电子制动力分配系统</a></li>
</ul>
<h3 id="牵引力控制-TCS-ASR-TRC"><a href="#牵引力控制-TCS-ASR-TRC" class="headerlink" title="牵引力控制(TCS/ASR/TRC)"></a>牵引力控制(TCS/ASR/TRC)</h3><p>牵引力控制系统Traction Control System，简称TCS。此外，ASR、TRC等也属于牵引力控制系统的范畴。牵引力控制系统的作用是使汽车在各种行驶状况下都能获得最佳的牵引力。<br>牵引力控制系统能防止车辆的雪地等湿滑路面上行驶时驱动轮的空转，使车辆能平稳地起步、加速。尤其在雪地或泥泞的路面，牵引力控制系统均能保证流畅的加速性能，防止车辆因驱动轮打滑而发生横移或甩尾。</p>
<ul>
<li><a href="https://v.qq.com/x/page/i0715piaqah.html" target="_blank" rel="noopener">TCS、ASR、TRC</a></li>
</ul>
<h3 id="车身稳定控制（ESP-DSC-VSC）"><a href="#车身稳定控制（ESP-DSC-VSC）" class="headerlink" title="车身稳定控制（ESP/DSC/VSC）"></a>车身稳定控制（ESP/DSC/VSC）</h3><p>ESP是英文ElectronicStabilityProgram的缩写，中文译成“电子稳定程序”。这一组系统通常是支援ABS及ASR(驱动防滑系统，又称牵引力控制系统)的功能。它通过对从各传感器传来的车辆行驶状态信息进行分析，然后向ABS、ASR发出纠偏指令，来帮助车辆维持动态平衡。ESP可以使车辆在各种状况下保持最佳的稳定性，在转向过度或转向不足的情形下效果更加明显。ESP最重要的特点就是它的主动性，如果说ABS是被动地作出反应，那么ESP却可以做到防患于未然。</p>
<ul>
<li><a href="http://www.iqiyi.com/w_19rr4ary85.html" target="_blank" rel="noopener">ESP车身稳定系统视频</a></li>
</ul>
<h3 id="刹车辅助-EBA-BAS-BA"><a href="#刹车辅助-EBA-BAS-BA" class="headerlink" title="刹车辅助(EBA/BAS/BA)"></a>刹车辅助(EBA/BAS/BA)</h3><p>机械制动辅助系统，也成为BAS。为EBA电子紧急制动辅助装置的前身。能判断驾驶者刹车动作，在紧急刹车时增加刹车力，缩短刹车距离。它根据驾驶员踩下踏板的力度及速度、将制动力适时加大，从而提供一个有效、可靠、安全的制动。对老人和女性（脚力不足者）帮助奇大。还有缩短制动距离的效果。</p>
<ul>
<li><a href="https://v.qq.com/x/search/?q=%E5%88%B9%E8%BD%A6%E8%BE%85%E5%8A%A9&stag=0&smartbox_ab=" target="_blank" rel="noopener">刹车辅助系统是什么？</a></li>
</ul>
<h3 id="车内中空锁"><a href="#车内中空锁" class="headerlink" title="车内中空锁"></a>车内中空锁</h3><p>1、中央控制：当驾驶员锁住其身边的车门时，其他车门也同时锁住，驾驶员可通过门锁开关同时打开各个车门，也可单独打开某个车门。<br>2、速度控制：当行车速度达到一定时，各个车门能自行锁上，防止乘员误操作车门把手而导致车门打开。<br>3、单独控制：除在驾驶员身边车门以外，还在其他门设置单独的弹簧锁开关，可独立地控制一个车门的打开和锁住。</p>
<ul>
<li><a href="https://haokan.baidu.com/v?vid=2885785447185922501&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">你真了解车内中控锁的用途么？</a></li>
</ul>
<h3 id="定速巡航航"><a href="#定速巡航航" class="headerlink" title="定速巡航航"></a>定速巡航航</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=14678380680692455927&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">定速巡航到底怎么用</a></li>
</ul>
<h3 id="自适应巡航-ACC"><a href="#自适应巡航-ACC" class="headerlink" title="自适应巡航(ACC)"></a>自适应巡航(ACC)</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=12199700142672505541" target="_blank" rel="noopener">ACC自适应巡航是个啥东西？</a></li>
</ul>
<h3 id="电子驻车"><a href="#电子驻车" class="headerlink" title="电子驻车"></a>电子驻车</h3><ul>
<li><a href="https://v.qq.com/x/page/p0619bd2c3y.html" target="_blank" rel="noopener">电子驻车</a></li>
</ul>
<h3 id="大灯调节"><a href="#大灯调节" class="headerlink" title="大灯调节"></a>大灯调节</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=384352568503521464&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">大灯调节</a></li>
</ul>
<h3 id="前后雾灯"><a href="#前后雾灯" class="headerlink" title="前后雾灯"></a>前后雾灯</h3><ul>
<li><a href="https://v.qq.com/x/cover/ahccpcpqdu9cyit/l0698zfo50u.html" target="_blank" rel="noopener">前后雾灯</a></li>
</ul>
<h3 id="大灯清洗"><a href="#大灯清洗" class="headerlink" title="大灯清洗"></a>大灯清洗</h3><ul>
<li><a href="http://v.bitauto.com/vplay/388920.html" target="_blank" rel="noopener">大灯清洗</a></li>
</ul>
<h3 id="感光大灯"><a href="#感光大灯" class="headerlink" title="感光大灯"></a>感光大灯</h3><ul>
<li><a href="https://v.qq.com/x/page/b0901w5l50y.html" target="_blank" rel="noopener">智能光感-这才是豪华车该有的大灯</a></li>
</ul>
<h3 id="日间行车灯"><a href="#日间行车灯" class="headerlink" title="日间行车灯"></a>日间行车灯</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=2583747335187405969&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">日间行车灯到底有没用?</a></li>
</ul>
<h3 id="汽车防夹手功能"><a href="#汽车防夹手功能" class="headerlink" title="汽车防夹手功能"></a>汽车防夹手功能</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=10616529883450756174" target="_blank" rel="noopener">为什么要买防夹手功能的车？</a></li>
</ul>
<h3 id="内后视镜自动防炫目"><a href="#内后视镜自动防炫目" class="headerlink" title="内后视镜自动防炫目"></a>内后视镜自动防炫目</h3><ul>
<li><a href="https://haokan.baidu.com/v?vid=6733134010090361135" target="_blank" rel="noopener">车内后视镜你真的会用吗？</a></li>
</ul>
<h3 id="City-Safety"><a href="#City-Safety" class="headerlink" title="City Safety"></a>City Safety</h3><ul>
<li>[Volvo CitySafety](Volvo CitySafety)</li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-09-20 </div>
			<div class="article-title"><a href="/2019/09/20/2019-09--20.hadoop/" >Hadoop</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。<br>用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。<br>Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。<br>Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wiki.apache.org/hadoop/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://www.imooc.com/learn/391" target="_blank" rel="noopener">认识Hadoop–基础篇</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-09-18 </div>
			<div class="article-title"><a href="/2019/09/18/2019-09--18.docker/" >Docker</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。<br>Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上, 基于go语言并遵从Apache2.0协议开源。<br>Docker 自 2013 年以来非常火热，无论是从 github 上的代码活跃度，还是Redhat在RHEL6.5中集成对Docker的支持, 就连 Google 的 Compute Engine 也支持 docker 在其之上运行。<br>一款开源软件能否在商业上成功，很大程度上依赖三件事 - 成功的 user case(用例), 活跃的社区和一个好故事。 dotCloud 自家的 PaaS 产品建立在docker之上，长期维护且有大量的用户，社区也十分活跃，接下来我们看看docker的故事。</p>
</blockquote>
<h2 id="Docker-理解"><a href="#Docker-理解" class="headerlink" title="Docker 理解"></a>Docker 理解</h2><ul>
<li>有 client 和 server 端</li>
<li>docker 网络可以通过 bridge 和 host 方式链接</li>
<li>image 运行起来变为 container</li>
<li>image 不能修改，但是 container 可以</li>
<li>每个 container 就是一个独立的虚拟机，可以进入查看运行</li>
<li>可以创建 image，创建的 image 可以依赖于现有的 image。例如 web 应用可以依赖 tomcat 的 image</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://www.imooc.com/learn/824" target="_blank" rel="noopener">第一个docker化的java应用-推荐</a></li>
<li><a href="https://www.imooc.com/learn/867" target="_blank" rel="noopener">docker 入门</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2019-09-17 </div>
			<div class="article-title"><a href="/2019/09/17/2019-09--17.golang/" >Golang</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><img src="https://baike.baidu.com/pic/go/953521/0/3b87e950352ac65c5eb643ddf9f2b21192138ae8?fr=lemma&ct=single" alt=""></p>
<blockquote>
<p>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。<br>罗伯特·格瑞史莫（Robert Griesemer），罗勃·派克（Rob Pike）及肯·汤普逊（Ken Thompson）于2007年9月开始设计Go，稍后Ian Lance Taylor、Russ Cox加入项目。Go是基于Inferno操作系统所开发的。Go于2009年11月正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后来追加了Windows系统下的实现。在2016年，Go被软件评价公司TIOBE 选为“TIOBE 2016 年最佳语言”。 目前，Go每半年发布一个二级版本（即从a.x升级到a.y）</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://golang.org" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://www.imooc.com/learn/968" target="_blank" rel="noopener">go 语言语法入门</a></li>
</ul>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
          <li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
        

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/2/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Ajax/">Ajax<span>9</span></a></li>
		
			<li><a href="/categories/AliPay/">AliPay<span>1</span></a></li>
		
			<li><a href="/categories/Android/">Android<span>14</span></a></li>
		
			<li><a href="/categories/AngularJS/">AngularJS<span>4</span></a></li>
		
			<li><a href="/categories/BackEnd/">BackEnd<span>5</span></a></li>
		
			<li><a href="/categories/Backbone/">Backbone<span>1</span></a></li>
		
			<li><a href="/categories/Bootstrap/">Bootstrap<span>2</span></a></li>
		
			<li><a href="/categories/C-C/">C/C++<span>1</span></a></li>
		
			<li><a href="/categories/Car/">Car<span>1</span></a></li>
		
			<li><a href="/categories/Css/">Css<span>9</span></a></li>
		
			<li><a href="/categories/Css3/">Css3<span>4</span></a></li>
		
			<li><a href="/categories/Database/">Database<span>4</span></a></li>
		
			<li><a href="/categories/Design/">Design<span>1</span></a></li>
		
			<li><a href="/categories/Docker/">Docker<span>2</span></a></li>
		
			<li><a href="/categories/Flutter/">Flutter<span>1</span></a></li>
		
			<li><a href="/categories/Git/">Git<span>1</span></a></li>
		
			<li><a href="/categories/Golang/">Golang<span>1</span></a></li>
		
			<li><a href="/categories/Hadoop/">Hadoop<span>1</span></a></li>
		
			<li><a href="/categories/Hexo/">Hexo<span>3</span></a></li>
		
			<li><a href="/categories/Html/">Html<span>18</span></a></li>
		
			<li><a href="/categories/Java/">Java<span>17</span></a></li>
		
			<li><a href="/categories/JavaScript/">JavaScript<span>82</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>8</span></a></li>
		
			<li><a href="/categories/Node-js/">Node.js<span>40</span></a></li>
		
			<li><a href="/categories/Powershell/">Powershell<span>1</span></a></li>
		
			<li><a href="/categories/Python/">Python<span>1</span></a></li>
		
			<li><a href="/categories/Read/">Read<span>9</span></a></li>
		
			<li><a href="/categories/Testing/">Testing<span>4</span></a></li>
		
			<li><a href="/categories/Tools/">Tools<span>16</span></a></li>
		
			<li><a href="/categories/Vue-js/">Vue.js<span>10</span></a></li>
		
			<li><a href="/categories/WeChat/">WeChat<span>4</span></a></li>
		
			<li><a href="/categories/jQuery/">jQuery<span>5</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/Document/">Document<span>8</span></a></li>
		
			<li><a href="/tags/Android/">Android<span>3</span></a></li>
		
			<li><a href="/tags/Jasmine/">Jasmine<span>1</span></a></li>
		
			<li><a href="/tags/Performence/">Performence<span>1</span></a></li>
		
			<li><a href="/tags/MongoDB/">MongoDB<span>2</span></a></li>
		
			<li><a href="/tags/Es6/">Es6+<span>2</span></a></li>
		
			<li><a href="/tags/Webpack/">Webpack<span>2</span></a></li>
		
			<li><a href="/tags/Karma/">Karma<span>1</span></a></li>
		
			<li><a href="/tags/MySQL/">MySQL<span>1</span></a></li>
		
			<li><a href="/tags/Bom/">Bom<span>10</span></a></li>
		
			<li><a href="/tags/Promise/">Promise<span>2</span></a></li>
		
			<li><a href="/tags/Chrome/">Chrome<span>2</span></a></li>
		
			<li><a href="/tags/Npm/">Npm<span>3</span></a></li>
		
			<li><a href="/tags/Library/">Library<span>7</span></a></li>
		
			<li><a href="/tags/PhantomJs/">PhantomJs<span>1</span></a></li>
		
			<li><a href="/tags/StdLib/">StdLib<span>11</span></a></li>
		
			<li><a href="/tags/OOP/">OOP<span>9</span></a></li>
		
			<li><a href="/tags/Mocha/">Mocha<span>1</span></a></li>
		
			<li><a href="/tags/Sublime/">Sublime<span>2</span></a></li>
		
			<li><a href="/tags/JSP/">JSP<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>23</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2020/11/10/2020-11-10-docker.starting/" ><i class="fa fa-file-o"></i>Docker</a>
      </li>
    
      <li>
        <a href="/2020/11/09/2020-11-09-android.sparseArray.arrayMap/" ><i class="fa fa-file-o"></i>性能优化:使用SparseArray和ArrayMap...</a>
      </li>
    
      <li>
        <a href="/2019/12/10/2019-12-10-android-compile-target-min-sdkversion/" ><i class="fa fa-file-o"></i>CompileSdkVersion、TargetSdk...</a>
      </li>
    
      <li>
        <a href="/2019/12/05/2019-12-05-android-rxjava/" ><i class="fa fa-file-o"></i>Android-rxjava</a>
      </li>
    
      <li>
        <a href="/2019/11/14/2019-11-14-java-NIO/" ><i class="fa fa-file-o"></i>NIO</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/freemind/" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/JesseQiu" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-linkedin"></i><a href="https://jesseqiu.github.io/" title="My Linkin account." target="_blank"]);">My LinkedIn</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>

  <div class="container-narrow">
  <footer> 
<!-- 不蒜子统计 -->

    <span id="busuanzi_container_site_pv">
            本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv" style='display:none'>
            本站访客数 <span id="busuanzi_value_site_uv"> </span>人
    </span>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<span>
  &copy; 2020 JesseChiu
  
</span>

<span>
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/" target="_blank" rel="noopener">Freemind</a>.    
</span>
 </footer>
</div> <!-- container-narrow -->

  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

  
</body>

   </html>
