<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 12 - Cease to struggle and you cease to live</title>
  <meta name="author" content="JesseChiu">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Cease to struggle and you cease to live"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Cease to struggle and you cease to live" type="application/atom+xml">
  
  
    <link href="/favicon.ico" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/spacelab.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <!-- analytics -->
  



</head>


 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Cease to struggle and you cease to live</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="">
			  <i class="fa fa-rss"></i>Rss
			</a>
		  </li>
		  
		  <li>
			<a href="/sitemap.xml" title="">
			  <i class="fa fa-sitemap"></i>Sitemap
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">Cease to struggle and you cease to live</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Keep on going never give up.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-05-20 </div>
			<div class="article-title"><a href="/2017/05/20/2017-05-20-SSH-工具使用/" >SSH 工具使用</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="一、什么是-SSH"><a href="#一、什么是-SSH" class="headerlink" title="一、什么是 SSH"></a>一、什么是 SSH</h2><ul>
<li>SSH 是英文 Secure Shell 简写，是一种加密协议</li>
<li>是 C/S 架构</li>
<li>可以把所有传输的数据进行加密</li>
<li>防止攻击和 DNS\IP 欺骗</li>
<li>传输的数据是经过压缩的，所以可以加快传输的速度</li>
<li>可以代替Telnet，又可以为FTP、Pop、甚至为PPP提供一个安全的”通道”。</li>
</ul>
<h2 id="二、SSH-配置文件"><a href="#二、SSH-配置文件" class="headerlink" title="二、SSH 配置文件"></a>二、SSH 配置文件</h2><h3 id="1-liunux-中-ssh-服务端配置文件"><a href="#1-liunux-中-ssh-服务端配置文件" class="headerlink" title="1. liunux 中 ssh 服务端配置文件"></a>1. liunux 中 ssh 服务端配置文件</h3><ul>
<li>默认路径：<code>/etc/ssh/sshd_config</code></li>
<li>注意，如果在该目录下有 <code>/etc/ssh/ssh_config</code> 少了一个 <code>d</code> 的文件，这个是 linux 服务器中也安装了 ssh 客户端，指的就是该客户端配置文件。</li>
</ul>
<h3 id="2-常用的配置项说明"><a href="#2-常用的配置项说明" class="headerlink" title="2. 常用的配置项说明"></a>2. 常用的配置项说明</h3><ul>
<li><code>Port     22</code>                                          #SSH端口设置，这里默认使用的是22端口</li>
<li><code>Protocol    2，1</code>                                #选择SSH协议版本</li>
<li><code>ListenAddress     0.0.0.0</code>                  #监听的网卡IP</li>
<li><code>PermitRootLogin     no</code>                        #是否允许root登入，默认是允许的</li>
<li><code>PasswordAuthentication yes</code>            #是否开启密码验证</li>
<li><code>PermitEmptyPasswords no</code>              #是否允许密码为空</li>
<li><code>PrintMotd no</code>                                        #登入后是否显示一些信息，如上次登入时间及地点等。</li>
<li><code>PrintLastLog yes</code>                                #显示上次登入的信息</li>
<li><code>KeepAlive yes</code>                                        #发送KeepAlive信息给客户端</li>
<li><code>MaxStartups 10</code>                                    #允许尚未登入的联机画面数</li>
<li><code>DenyUsers *</code>                                            #禁止用户登录，*表示所有用户</li>
<li><code>AllowUsers *</code>                                        #允许用户登录</li>
</ul>
<h2 id="三、操作实战"><a href="#三、操作实战" class="headerlink" title="三、操作实战"></a>三、操作实战</h2><h3 id="1-基于口令方式认证"><a href="#1-基于口令方式认证" class="headerlink" title="1. 基于口令方式认证"></a>1. 基于口令方式认证</h3><ul>
<li><img src="http://od6sd4xau.bkt.clouddn.com/ssh-1.png" alt="putty 输入登入 ip 地址"><br>其中的 4，5 步骤可选择跳过，建议保存，这样下次只要点击保存的会话名称，就可以直接登入到 <code>cmd</code> 界面，不用每次都输入一串 id 地址。</li>
<li><img src="http://od6sd4xau.bkt.clouddn.com/ssh-2.png" alt="输入用户名和密码"></li>
</ul>
<h3 id="2-基于密钥方式认证"><a href="#2-基于密钥方式认证" class="headerlink" title="2. 基于密钥方式认证"></a>2. 基于密钥方式认证</h3><p>在 SSH 2.0 协议中支持使用密钥方式登入</p>
<ul>
<li><p>在 linux 服务器中使用 <code>ssh-keygen</code> 命令生成公钥与密钥<br><img src="http://od6sd4xau.bkt.clouddn.com/ssh-3.png" alt="生成 rsa 密钥"><br>注意，在这步中生成的 <strong>authroized_keys</strong> 文件名称必须一样，不能错。</p>
</li>
<li><p>修改 <strong>authroized_keys</strong> 文件权限<br><code>chmod 600 authroized_keys</code>，不然会限制访问</p>
</li>
<li><p>通过 winscp 把生成的 <strong>id_rsa</strong> 文件拷贝到本地<br><img src="http://od6sd4xau.bkt.clouddn.com/ssh-4.png" alt="使用 winscp 拷贝文件"><br><img src="http://od6sd4xau.bkt.clouddn.com/ssh-5.png" alt="使用 winscp 拷贝文件"></p>
</li>
<li><p>使用 <code>puttygen.exe</code> 软件转换上一步的 <code>id_rsa</code> 文件为 <code>*.ppk</code> 文件,因为 <code>putty</code> 不能识别 <code>ras</code> 文件，所有需要转换下<br><img src="http://od6sd4xau.bkt.clouddn.com/ssh-6.png" alt="puttygen.exe 转换文件"></p>
</li>
<li><p>设置 putty 为密钥认证方式登入<br><img src="http://od6sd4xau.bkt.clouddn.com/ssh-7.png" alt="密钥方式登入-1"><br><img src="http://od6sd4xau.bkt.clouddn.com/ssh-8.png" alt="密钥方式登入-2"><br><img src="http://od6sd4xau.bkt.clouddn.com/ssh-9.png" alt="密钥方式登入-3"></p>
</li>
<li><p>保存登入信息<br><img src="https://raw.githubusercontent.com/Jesse-Chiu/images/master/ssh-10.png" alt="保存登入会话信息"></p>
</li>
</ul>
<h2 id="四、对应的客户端软件"><a href="#四、对应的客户端软件" class="headerlink" title="四、对应的客户端软件"></a>四、对应的客户端软件</h2><ul>
<li><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">putty 官网下载地址</a></li>
<li>[Xshell]</li>
<li>[SecureCRT]</li>
<li>[Plink] 如果安装了 putty 客户端，默认就有该文件</li>
<li><a href="http://winscp.net/eng/docs/lang:chs" target="_blank" rel="noopener">winscp</a> windows 图形界面操作 linux 的文件传输</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/macrossdzh/article/details/5691924" target="_blank" rel="noopener">ssh 协议介绍</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-05-03 </div>
			<div class="article-title"><a href="/2017/05/03/2017-05-03-微信-JSSDK-调用实例/" >微信 JSSDK 调用实例</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>有时我们需要在网页中调用微信的一些功能，例如，打开摄像头扫描，分享好友的微信功能，这时就需要在网页中调用 <code>jssdk</code>,但是这需要一个认证过程，本文主要就会是对微信公众号网页开发中调用 <code>jssdk</code> 备忘，后台语言 <code>nodejs</code>。</p>
<h2 id="一、JS-接口安全域名填写"><a href="#一、JS-接口安全域名填写" class="headerlink" title="一、JS 接口安全域名填写"></a>一、JS 接口安全域名填写</h2><p>登入公众号后台管理系统 -&gt; 公众号设置 -&gt; 功能设置，设置 <strong>JS接口安全域名设置</strong>。这里需要注意的是，域名必须是 <strong>一级域名</strong>，且只能是域名部分，例如: <code>jessechiu.com</code>,不能包含有 <code>http://</code> 等其它部分。<br>ps: 回测验证可以支持二级域名: <code>test.jessechiu.com</code></p>
<h2 id="二、后端代码部分"><a href="#二、后端代码部分" class="headerlink" title="二、后端代码部分"></a>二、后端代码部分</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs 部分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 config 签名认证信息入口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">router.all(<span class="string">'/jssdk-config'</span>,(req,res,next)=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">console</span>.log(<span class="string">'req.body.url: '</span> \+ req.body.url);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	tools.getJsConfig(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">		debug: <span class="literal">false</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">		jsApiList: [<span class="string">'scanQRCode'</span>, <span class="string">'chooseImage'</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">		url: req.body.url</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">		res.send(result)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要调用 jssdk 函数的页面入口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/jssdk-demo'</span>, (req, res, next) =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	res.render(<span class="string">'jssdk-demo'</span>, &#123;&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h2 id="三、网页部分代码"><a href="#三、网页部分代码" class="headerlink" title="三、网页部分代码"></a>三、网页部分代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>绑定手机号<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=0"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/static/stylesheets/style.css"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://res.wx.qq.com/open/js/jweixin-1.0.0.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"scan"</span>&gt;</span>调用扫描<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"uploadImg"</span>&gt;</span>上传图片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">        $.ajax(&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            url: <span class="string">'http://jessechiu.com/jssdk-config/'</span>, <span class="comment">// 请求签名认证数据地址</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            type: <span class="string">'POST'</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            data: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                <span class="string">'cmd'</span>: <span class="string">'get_js_config'</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                <span class="string">'url'</span>: <span class="string">'http://jessechiu.com/jssdk-demo/'</span> <span class="comment">// 这里的地址需要更换为你要使用 jssk api 的网页地址，也就是本文件的网址</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            &#125;, <span class="comment">// 需要调用 jssdk 的地址，也就是本网页地址</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            datatype: <span class="string">'json'</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                handleJsConfig(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">handleJsConfig</span><span class="params">(data)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'handleJsConfig(): '</span>\ + <span class="built_in">JSON</span>.stringify(data));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            <span class="comment">// 从后台得到签名认证信息，进行认证</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            wx.config(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            <span class="comment">// 认证出错时调用</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            wx.error(<span class="function"><span class="keyword">function</span><span class="params">(res)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'wx.error(): '</span>\ + <span class="built_in">JSON</span>.stringify(res));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                <span class="comment">// alert('wx.error: ' \+ JSON.stringify(res));</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            <span class="comment">// 认证结束时调用，所以调用 sdk 中的函数需要写在此回调函数中</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">            wx.ready(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'wx.ready()'</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">                wx.checkJsApi(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                    jsApiList: [<span class="string">'scanQRCode'</span>, <span class="string">'chooseImage'</span>], <span class="comment">// 需要检测的JS接口列表，所有JS接口列表见附录2,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                    success: <span class="function"><span class="keyword">function</span><span class="params">(res)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(<span class="string">'success: '</span>\ + <span class="built_in">JSON</span>.stringify(res));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        <span class="comment">// alert(JSON.stringify(res));</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">                    &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                    fail: <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        <span class="comment">// alert('fail: ' \+ JSON.stringify(err));</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(<span class="string">'fail: '</span>\ + <span class="built_in">JSON</span>.stringify(err));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                <span class="keyword">let</span> scanBtn = <span class="built_in">document</span>.getElementById(<span class="string">'scan'</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                <span class="keyword">let</span> uploadImgBtn = <span class="built_in">document</span>.getElementById(<span class="string">'uploadImg'</span>);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                scanBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">                    wx.scanQRCode(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        needResult: <span class="number">0</span>, <span class="comment">// 默认为0，扫描结果由微信处理，1则直接返回扫描结果，</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        scanType: [<span class="string">"qrCode"</span>, <span class="string">"barCode"</span>], <span class="comment">// 可以指定扫二维码还是一维码，默认二者都有</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        success: <span class="function"><span class="keyword">function</span><span class="params">(res)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                            <span class="keyword">var</span> result = res.resultStr; <span class="comment">// 当ne</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">                            edResult 为 1 时， 扫码返回的结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                            <span class="built_in">console</span>.log(<span class="string">'success: '</span>\ + <span class="built_in">JSON</span>.stringify(res));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                            <span class="comment">// alert('success: ' \+ JSON.stringify(res));</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">                        &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        fail: <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                            <span class="comment">// alert('fail: ' \+ JSON.stringify(err));</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                            <span class="built_in">console</span>.log(<span class="string">'fail: '</span>\ + <span class="built_in">JSON</span>.stringify(err));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">                    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                uploadImgBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">                    wx.chooseImage(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        count: <span class="number">1</span>, <span class="comment">// 默认9</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        sizeType: [<span class="string">'original'</span>, <span class="string">'compressed'</span>], <span class="comment">// 可以指定是原图还是压缩图，默认二者都有</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        sourceType: [<span class="string">'album'</span>, <span class="string">'camera'</span>], <span class="comment">// 可以指定来源是相册还是相机，默认二者都有</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        success: <span class="function"><span class="keyword">function</span><span class="params">(res)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                            <span class="keyword">var</span> localIds = res.localIds; <span class="comment">//返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                            <span class="built_in">console</span>.log(<span class="string">'success: '</span>\ + <span class="built_in">JSON</span>.stringify(res));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                            <span class="comment">// alert('success: ' \+ JSON.stringify(res));</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">                        &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                        fail: <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">                            <span class="comment">// alert('fail: ' \+ JSON.stringify(err));</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line"><span class="javascript">                            <span class="built_in">console</span>.log(<span class="string">'fail: '</span>\ + <span class="built_in">JSON</span>.stringify(err));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">                    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></pre></td></tr></table></figure>

<h2 id="四、错误排查"><a href="#四、错误排查" class="headerlink" title="四、错误排查"></a>四、错误排查</h2><h3 id="1-config-invalid-signature"><a href="#1-config-invalid-signature" class="headerlink" title="1. config:invalid signature"></a>1. <code>config:invalid signature</code></h3><p>如果是invalid signature签名错误。建议按如下顺序检查：<br>1.确认签名算法正确，可用 <code>http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign</code> 页面工具进行校验。<br>2.确认 <code>config</code> 中 <code>nonceStr（js中驼峰标准大写S）</code>, <code>timestamp</code> 与用以签名中的对应 <code>noncestr</code>, <code>timestamp</code> 一致。<br>3.确认 <code>url</code> 是页面完整的 <code>url(请在当前页面 alert(location.href.split(&#39;#&#39;)[0])</code> 确认，包括 <code>http(s)://</code> 部分，以及 <code>?</code> 后面的 <code>GET</code> 参数部分,但不包括 <code>#hash</code>后面的部分。<br>4.确认 <code>config</code> 中的 <code>appid</code> 与用来获取 <code>jsapi_ticket</code> 的 <code>appid</code> 一致。<br>5.确保一定缓存 <code>access_token</code> 和 <code>jsapi_ticket</code></p>
<h3 id="2-分享给朋友接口没反应"><a href="#2-分享给朋友接口没反应" class="headerlink" title="2. 分享给朋友接口没反应"></a>2. 分享给朋友接口没反应</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareMessage</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  wx.onMenuShareAppMessage(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      title: <span class="string">''</span>, <span class="comment">// 分享标题</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      desc: <span class="string">''</span>, <span class="comment">// 分享描述</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      link: <span class="string">''</span>, <span class="comment">// 分享链接，该链接域名必须与当前企业的可信域名一致</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      imgUrl: <span class="string">''</span>, <span class="comment">// 分享图标</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      type: <span class="string">''</span>, <span class="comment">// 分享类型,music、video或link，不填默认为link</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      dataUrl: <span class="string">''</span>, <span class="comment">// 如果type是music或video，则要提供数据链接，默认为空</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">          <span class="comment">// 用户确认分享后执行的回调函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      cancel: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">          <span class="comment">// 用户取消分享后执行的回调函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>jssdk 的认证都 ok，但是点击调用上面的的函数界面就是没有反应。如果你也碰到这个问题，说明没理解该 API 的用处，也算是个坑吧。<br>正确的理解应该是: <code>分享给朋友 接口不是指直接能够分享朋友圈，而是指它会改变右上角菜单里的分享内容</code>; <a href="http://qydev.weixin.qq.com/qa/index.php?qa=6428&qa_1=%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%8F%8D%E5%BA%94%EF%BC%8C%E4%BD%BF%E7%94%A8checkjsapi%E6%A3%80%E6%B5%8B%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%BF%94%E5%9B%9Etrue&show=6428#q6428" target="_blank" rel="noopener">参考</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="noopener">微信JS-SDK说明文档</a></li>
<li><a href="http://blog.csdn.net/sinat_29843547/article/details/49357193" target="_blank" rel="noopener">nodejs jssdk 调用参考实例</a></li>
<li><a href="http://www.thinkphp.cn/code/1568.html" target="_blank" rel="noopener">微信config:invalid signature这个错误的解决办法</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-05-02 </div>
			<div class="article-title"><a href="/2017/05/02/2017-05-02-微信网页授权认证实例/" >微信网页授权认证实例</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文记录，微信网页认证调试过程，开发环境 <code>node.js</code></p>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">bash $ npm install wechat-oauth</span></pre></td></tr></table></figure>

<h2 id="二、node-js-中引入"><a href="#二、node-js-中引入" class="headerlink" title="二、node.js 中引入"></a>二、node.js 中引入</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> OAuth = <span class="built_in">require</span>(<span class="string">'wechat-oauth'</span>); <span class="keyword">var</span> client = <span class="keyword">new</span> OAuth(<span class="string">'your appid'</span>, <span class="string">'your secret'</span>);</span></pre></td></tr></table></figure>

<p>上面的 <code>your appid</code> 是你公众号的 id，<code>your secret</code> 是你公众号密钥，在公众号后台都可以查看到</p>
<h2 id="三、转换网址"><a href="#三、转换网址" class="headerlink" title="三、转换网址"></a>三、转换网址</h2><p>在微信中跳转到外部链接，如果需要在该页面获取到微信用户的 <code>openid</code> 或者 <code>userinfo</code> 就需要微信授权。 所以首先需要把跳转的页面地址转换为带参数的认证过的网址。 <code>js let authUrl = client.getAuthorizeURL(redirect, state, scope);</code></p>
<ul>
<li>redirect: 需要跳转的页面地址</li>
<li>state: 可自定义传递参数，长度不能超过 128 字节</li>
<li>scope：<code>snsapi_base</code>：只获取 <code>openid</code> ; <code>snsapi_userinfo</code>: 还可以获取微信用户信息。</li>
</ul>
<p>例如: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> authUrl = client.getAuthorizeURL(<span class="string">'http://jessechiu.com/wechat'</span>, <span class="string">'hello'</span>, <span class="string">'userinfo'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// authUrl: https://open.weixin.qq.com/connect/oauth2/authorize?appi d=wx7a1c56bbd19d157e&amp;redirect_uri=http%3A%2F%2Fjessechiu.com%2Fwechat&amp;response_ type=code&amp;scope=snsapi_userinfo&amp;state=hello#wechat_redirect</span></span></pre></td></tr></table></figure>

<p><strong>注意：官方文档规定，转换后的网址长度不能超过 256 字节</strong></p>
<h2 id="四、获取用户信息"><a href="#四、获取用户信息" class="headerlink" title="四、获取用户信息"></a>四、获取用户信息</h2><p>在上步生成的 <code>authUrl</code> 地址，当用户点击或者从菜单 <code>VIEW</code> 事件进入时，可以通过后台的对应路由获取对应的参数信息，进而获取用户的 <code>openid</code> 和 <code>userinfo</code> 信息。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/wechat'</span>,(req,res,next)=&gt;&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">let</span> code = req.query.code; <span class="comment">// 该值有微信后台生成，用来后面函数操作 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">let</span> state = req.query.state;<span class="comment">// 网址转换时传人的参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">console</span>.log(<span class="string">'\n /wechat -&gt; req.query.code: '</span> \+ code); <span class="built_in">console</span>.log(<span class="string">'\n /wechat -&gt; req.query.state: '</span> \+ state);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	tools.getAuthorizeOpenid(code)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	.then(tools.getAuthorizeUserinfo)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	.then(<span class="function">(<span class="params">userinfo</span>)=&gt;</span>&#123; res.render(<span class="string">'wechat'</span>,&#123;&#125;); &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">console</span>.error(<span class="string">'\n err: '</span> \+ <span class="built_in">JSON</span>.stringify(err)); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	&#125;); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/wiki/9/01f711493b5a02f24b04365ac5d8fd95.html" target="_blank" rel="noopener">网页授权获取用户基本信息</a></li>
<li><a href="https://github.com/node-webot/wechat-oauth" target="_blank" rel="noopener">wechat-oauth git</a></li>
<li><a href="http://doxmate.cool/node-webot/wechat-oauth/api.html" target="_blank" rel="noopener">微信公共平台 OAuth API 文档</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-04-14 </div>
			<div class="article-title"><a href="/2017/04/14/2017-04-14-node-js-version/" >版本管理</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="语义版本"><a href="#语义版本" class="headerlink" title="语义版本"></a>语义版本</h2><p>npm采用”语义版本“（semver）管理软件包。</p>
<p>所谓语义版本，就是指版本号为 <code>a.b.c</code> 的形式，其中 <code>a</code> 是大版本号，<code>b</code> 是小版本号，<code>c</code> 是补丁号。</p>
<p>一个软件发布的时候，默认就是 <code>v1.0.0</code> 版。如果以后发布补丁，就增加最后一位数字，比如 <code>v1.0.1</code>；如果增加新功能，且不影响原有的功能，就增加中间的数字（即小版本号），比如 <code>v1.1.0</code>；如果引入的变化，破坏了向后兼容性，就增加第一位数字（即大版本号），比如 <code>v2.0.0</code>。</p>
<p>注意，如果大版本不到 v1.0.0（即v0.x.y）时，不兼容变动应该修改小版本号，即从<code>v0.4.1</code>升级到<code>v0.5.0</code>。</p>
<p>npm允许使用特殊符号，指定所要使用的版本范围，假定当前版本是1.0.4。</p>
<ul>
<li>只接受补丁包：<code>1.0</code>或者<code>1.0.x</code>或者<code>~1.0.4</code></li>
<li>只接受小版本和补丁包：<code>1</code>或者<code>1.x</code>或者<code>^1.0.4</code>。这是<code>--save</code>或<code>save-dev</code>安装时，默认的版本范围。</li>
<li>接受所有更新：<code>*</code> or <code>x</code></li>
</ul>
<p>对于<code>~</code>和<code>^</code>，要注意区分。前者表示接受当前小版本（如果省略小版本号，则是当前大版本）的最新补丁包，后者表示接受当前大版本的最新小版本和最新补丁包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">~<span class="number">2.2</span><span class="number">.1</span> <span class="comment">// 接受2.2.1，不接受2.3.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">^<span class="number">2.2</span><span class="number">.1</span> <span class="comment">// 接受2.2.1和2.3.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">~<span class="number">2.2</span> <span class="comment">// 接受2.2.0和2.2.1，不接受2.3.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">^<span class="number">2.2</span> <span class="comment">// 接受2.2.0、2.2.1和2.3.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">~<span class="number">2</span> <span class="comment">// 接受2.0.0、2.1.0、2.2.0、2.2.1和2.3.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">^<span class="number">2</span> <span class="comment">// 接受2.0.0、2.1.0、2.2.0、2.2.1和2.3.0</span></span></pre></td></tr></table></figure>

<p><code>npm</code>默认使用<code>^</code>，使用下面的命令，可以改变这个行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> save-prefix=<span class="string">'~'</span></span></pre></td></tr></table></figure>

<p>此外，还可以使用数学运算符（比如<code>&gt;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;=</code>或者<code>&lt;=</code>等），指定版本范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">2.1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">1.0</span><span class="number">.0</span> - <span class="number">1.2</span><span class="number">.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1.0</span><span class="number">.0</span>-alpha</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt;= <span class="number">1.0</span><span class="number">.0</span>-rc<span class="number">.0</span> &lt; <span class="number">1.0</span><span class="number">.1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">^<span class="number">2</span> &lt; <span class="number">2.2</span> || &gt; <span class="number">2.3</span></span></pre></td></tr></table></figure>

<p>以上都是合法的版本指定方式。</p>
<p>注意，如果使用连字号，它的两端必须有空格，比如<code>1.0.0 - 2.0.0</code>。如果不带空格，会被npm理解成预发布的tag，比如<code>1.0.0-rc.1</code>。</p>
<p>npm官方提供一个在线工具<a href="http://semver.npmjs.com/" target="_blank" rel="noopener">semver.npmjs.com</a>，可以查看不同语义版本涵盖的版本范围。</p>
<h2 id="npm-version"><a href="#npm-version" class="headerlink" title="npm version"></a>npm version</h2><p><code>npm version</code>命令用来修改项目的版本号。当你完成代码修改，要发布新版本的时候，就用这个命令更新一下软件的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm version &lt;update_type&gt; -m <span class="string">"&lt;message&gt;"</span></span></pre></td></tr></table></figure>

<p><code>npm version</code>命令更新<code>package.json</code>里面的版本号，并且新增一个Git commit记录，以及一个新的Git tag。<code>-m</code>参数（或者<code>--message</code>）用来指定生成Git commit时的提交说明。</p>
<p>注意，由于要生成Git commit，所以执行这个命令前，当前目录里面的所有变动，都必须要保存进Git，否则会报错。</p>
<p><code>npm version</code>命令可以带有以下参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改为指定的版本号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ npm version &lt;x.y.z&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改语义版本的大版本、小版本、补丁号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例来说，原版本是1.1.1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># patch 生成 1.1.2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># minor 生成 1.2.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># major 生成 2.0.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">$ npm version &lt;major|minor|patch&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改语义版本的大版本、小版本、补丁号，并且加上预发号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例来说，原版本是1.5.1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># premajor 生成 v2.0.0-0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># preminor 生成 v1.6.0-0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># prepatch 生成 v1.5.2-0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># prerelease 将原来的预发号加1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">$ npm version &lt;premajor|preminor|prepatch|prerelease&gt;</span></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm version patch -m <span class="string">"Version %s - xxxxxx"</span></span></pre></td></tr></table></figure>

<p>上面命令的<code>%s</code>表示新的版本号。</p>
<p>如果<code>package.json</code>的<code>scripts</code>属性里面，指定了<code>preversion</code>、<code>version</code>、<code>postversion</code>命令，<code>npm version</code>命令会自动执行这些脚本。执行顺序如下。</p>
<ol>
<li>检查当前目录是否有未提交的文件变动，如果有就报错。</li>
<li>运行<code>preversion</code>脚本。该脚本拿到的是旧版本号，典型用途就是运行测试。</li>
<li>增加<code>package.json</code>里面的版本号。</li>
<li>运行<code>version</code>脚本，此时拿到的是新版本号。</li>
<li>提交commit，并在Git里面生成一个tag。</li>
<li>运行<code>postversion</code>脚本，典型用途是推送新生成的commit和tag。</li>
</ol>
<p>下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"preversion"</span>: <span class="string">"npm test"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"version"</span>: <span class="string">"npm run build &amp;&amp; git add -A dist"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"postversion"</span>: <span class="string">"git push &amp;&amp; git push --tags &amp;&amp; rm -rf build/temp"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中，增加版本号之前会运行测试，只有全部通过，才会新增版本号；版本号增加以后，会进行构建，然后将新生成的<code>dist</code>目录，加入Git的暂存区；最后，推送到远程仓库，并且删除构建所用的临时目录。</p>
<p>由于更新npm网站的唯一方法，就是发布一个新的版本。因此，除了第一次发布，这个命令与<code>npm publish</code>几乎是配套的，先使用它，再使用<code>npm publish</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm version patch -m <span class="string">"Version %s - add sweet badges"</span>$</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ git push &amp;&amp; git push --tags (or git push origin master --tags)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ npm publish</span></pre></td></tr></table></figure>

<h2 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h2><p>对于大型项目来说，发布一个大版本，大致会经过以下的流程，即预发一些预备版本。</p>
<ul>
<li>v0.5.0-alpha1</li>
<li>v0.5.0-beta1</li>
<li>v0.5.0-beta2</li>
<li>v0.5.0-rc1</li>
<li>v0.5.0-rc2</li>
<li>v0.5.0</li>
</ul>
<p>操作步骤如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新版本号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ npm version 0.5.0-alpha1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用alpha1标签发布该版本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">$ npm publish --tag alpha1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装使用该版本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">npm i &lt;your package name&gt;@alpha1</span></pre></td></tr></table></figure>

<h2 id="模块标签"><a href="#模块标签" class="headerlink" title="模块标签"></a>模块标签</h2><p>npm允许为模块的某个版本，新建一个标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;]</span></pre></td></tr></table></figure>

<p>另一种方法是发布的时候，加上标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm publish --tag=beta</span></pre></td></tr></table></figure>

<p>有了标签以后，就可以指定安装该标签的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm install &lt;name&gt;@&lt;tag&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ npm install --tag &lt;tag&gt;</span></pre></td></tr></table></figure>

<p>常见的标签有<code>latest</code>、<code>stable</code>、<code>next</code>等。</p>
<p>npm默认会为最新一次发布的版本，新建<code>latest</code>标签。然后，下载的时候，默认是下载带有<code>latest</code>标签的版本。但是，这可能并不是我们想要的行为。比如，当前最新版本是4.2版，然后发布了一个3.6版，<code>latest</code>的标签就会打在3.6版上面，用户<code>npm install</code>安装的就是这个版本。</p>
<p>为了避免这个问题，可以为3.6版加上<code>previous</code>标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ npm publish --tag=previous</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">$ npm install &lt;package&gt;@previous</span></pre></td></tr></table></figure>

<p><code>package.json</code>文件可以设置默认标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"publishConfig"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"tag"</span>: <span class="string">"next"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的<code>publishConfig</code>设置了最新发布的默认标签是<code>next</code>。<code>publishConfig</code>属性设置的值，可以在publish过程中使用。</p>
<h2 id="npm-outdated"><a href="#npm-outdated" class="headerlink" title="npm outdated"></a>npm outdated</h2><p><code>npm outdated</code>命令列出项目所有依赖的当前版本号与最新版本号，提示你是否需要更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm outdated</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Package      Current   Wanted   Latest  Location</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">glob          5.0.15   5.0.15    6.0.1  <span class="built_in">test</span>-outdated-output</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">npm            3.5.1    3.5.2    3.5.1  <span class="built_in">test</span>-outdated-output</span></pre></td></tr></table></figure>

<p>每个项目依赖的模块，都会输出三个版本号。<code>Current</code>表示当前使用的版本，<code>Wanted</code>表示符合预置条件的最新版本，<code>Latest</code>表示最新发布的版本。</p>
<blockquote>
<p>如果需要更新所有版本到 <code>Wanted</code> 列表显示的版本，可以使用 <code>npm update</code> 命令。</p>
</blockquote>
<h2 id="npm-shrinkwrap"><a href="#npm-shrinkwrap" class="headerlink" title="npm shrinkwrap"></a>npm shrinkwrap</h2><p>对于一个项目来说，通常不会写死依赖的npm模块的版本。比如，开发时使用某个模块的版本是1.0，那么等到用户安装时，如果该模块升级到1.1，往往就会安装1.1。</p>
<p>但是，对于开发者来说，有时最好锁定所有依赖的版本，防止模块升级带来意想不到的问题。但是，由于模块自己还依赖别的模块，这一点往往很难做到。举例来说，项目依赖A模块，A模块依赖B模块。即使写死A模块的版本，但是B模块升级依然可能导致不兼容。</p>
<p><code>npm shrinkwrap</code>命令就是用来彻底锁定所有模块的版本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm shrinkwrap</span></pre></td></tr></table></figure>

<p>运行上面这个命令以后，会在项目目录下生成一个npm-shrinkwrap.json文件，里面包含当前项目用到的所有依赖（包括依赖的依赖，以此类推），以及它们的准确版本，也就是当前正在使用的版本。</p>
<p>只要存在<code>npm-shrinkwrap.json</code>文件，下一次用户使用<code>npm install</code>命令安装依赖的时候，就会安装所有版本完全相同的模块。</p>
<p>如果执行<code>npm shrinkwrap</code>的时候，加上参数dev，还可以记录devDependencies字段中模块的准确版本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm shrinkwrap --dev</span></pre></td></tr></table></figure>

<h2 id="npm-prune"><a href="#npm-prune" class="headerlink" title="npm prune"></a>npm prune</h2><p><code>npm prune</code>命令与<code>npm shrinkwrap</code>配套使用。使用<code>npm shrinkwrap</code>的时候，有时可能存在某个已经安装的模块不在<code>dependencies</code>字段内的情况，这时<code>npm shrinkwrap</code>就会报错。</p>
<p><code>npm prune</code>命令可以移除所有不在<code>dependencies</code>字段内的模块。如果指定模块名，则移除指定的模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ npm prune</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ npm prune &lt;package name&gt;</span></pre></td></tr></table></figure>


	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-04-14 </div>
			<div class="article-title"><a href="/2017/04/14/2017-04-14-node-js-url/" >url 模块</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><code>url</code>模块用于生成和解析URL。该模块使用前，必须加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────────────────────┐</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">│                                            href                                             │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">├──────────┬──┬─────────────────────┬─────────────────────┬───────────────────────────┬───────┤</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">│ protocol │  │        auth         │        host         │           path            │ hash  │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">│          │  │                     ├──────────────┬──────┼──────────┬────────────────┤       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">│          │  │                     │   hostname   │ port │ pathname │     search     │       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">│          │  │                     │              │      │          ├─┬──────────────┤       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">│          │  │                     │              │      │          │ │    query     │       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">"  https:   //    user   :   pass   @ sub.host.com : 8080   /p/a/t/h  ?  query=string   #hash "</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">│          │  │          │          │   hostname   │ port │          │                │       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">│          │  │          │          ├──────────────┴──────┤          │                │       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">│ protocol │  │ username │ password │        host         │          │                │       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">├──────────┴──┼──────────┴──────────┼─────────────────────┤          │                │       │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">│   origin    │                     │       origin        │ pathname │     search     │ hash  │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">├─────────────┴─────────────────────┴─────────────────────┴──────────┴────────────────┴───────┤</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">│                                            href                                             │</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">└─────────────────────────────────────────────────────────────────────────────────────────────┘</span></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span></pre></td></tr></table></figure>

<h2 id="url-parse"><a href="#url-parse" class="headerlink" title="url.parse()"></a>url.parse()</h2><p><code>url.parse()</code> 将一个 URL 字符串转换为URL对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">url.parse(<span class="string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">protocol</span>: <span class="string">'http:'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  auth: <span class="string">'user:pass'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  host: <span class="string">'host.com:8080'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  port: <span class="string">'8080'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  hostname: <span class="string">'host.com'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  hash: <span class="string">'#hash'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  search: <span class="string">'?query=string'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  query: <span class="string">'query=string'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  pathname: <span class="string">'/p/a/t/h'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  path: <span class="string">'/p/a/t/h?query=string'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  href: <span class="string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</span> &#125;</span></pre></td></tr></table></figure>

<h2 id="url-format"><a href="#url-format" class="headerlink" title="url.format()"></a>url.format()</h2><p><code>url.format()</code> 方法允许将一个 URL 对象转换为 URL 字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">url.format(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     protocol: <span class="string">'http:'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     host: <span class="string">'www.example.com'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     pathname: <span class="string">'/p/a/t/h'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     search: <span class="string">'query=string'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">'http://www.example.com/p/a/t/h?query=string'</span></span></pre></td></tr></table></figure>

<h2 id="url-resolve-from-to"><a href="#url-resolve-from-to" class="headerlink" title="url.resolve(from, to)"></a>url.resolve(from, to)</h2><p><code>url.resolve</code>方法用于生成URL。它的第一个参数是基准URL，其余参数依次根据基准URL，生成对应的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">url.resolve(<span class="string">'/one/two/three'</span>, <span class="string">'four'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// '/one/two/four'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">url.resolve(<span class="string">'http://example.com/'</span>, <span class="string">'/one'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'http://example.com/one'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">url.resolve(<span class="string">'http://example.com/one/'</span>, <span class="string">'two'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'http://example.com/one/two'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">url.resolve(<span class="string">'http://example.com/one'</span>, <span class="string">'/two'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'http://example.com/two'</span></span></pre></td></tr></table></figure>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-04-14 </div>
			<div class="article-title"><a href="/2017/04/14/2017-04-14-node-js-timer/" >定时器</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>”定时器“指的是Node的一些特定方法，可以让函数在指定时间执行。</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>“定时器”的实现是建立在“Event Loop”机制（中文译为“事件循环”）基础上的。所谓“Event Loop”是指Node的异步回调函数的处理机制。如果遇到异步操作，Node会把这些操作交给操作系统处理，自己继续往下执行。然后，等到空闲时，不断循环检查操作系统是否返回结果。一旦得到结果，就执行对应的回调函数。</p>
<p>“Event Loop”由Node底层的libuv库的<a href="https://github.com/libuv/libuv/blob/master/src/unix/core.c#L321" target="_blank" rel="noopener"><code>uv_run</code></a>函数实现，它的代码大致如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    uv__update_time(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    uv__run_timers(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ran_pending &#x3D; uv__run_pending(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    uv__run_idle(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    uv__run_prepare(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    timeout &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    if ((mode &#x3D;&#x3D; UV_RUN_ONCE &amp;&amp; !ran_pending) || mode &#x3D;&#x3D; UV_RUN_DEFAULT)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      timeout &#x3D; uv_backend_timeout(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    uv__io_poll(loop, timeout);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    uv__run_check(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    uv__run_closing_handles(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>每一轮事件循环，就会执行一次上面的代码。它的基本步骤如下。</p>
<ol>
<li>更新当前时间（<code>uv__update_time</code>）</li>
<li>执行<code>setTimeout</code>和<code>setInterval</code>（<code>uv__run_timers</code>）</li>
<li>执行（以前轮次的）定时器的回调函数（<code>uv__run_pending</code>）</li>
<li>执行I/O事件的回调函数（<code>uv__io_poll</code>）</li>
<li>执行<code>setImmediate</code>（<code>uv__run_check</code>）</li>
</ol>
<p>这里需要注意的是，执行<code>setTimeout</code>、<code>setInterval</code>和<code>setImmediate</code>这三个方法时，它们指定的回调函数是不会在本轮事件循环执行的，而是会放入一个数组，在以后轮次的事件循环清空。</p>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h2><p><code>process.nextTick</code>方法用于指定在本轮Event Loop即将结束、下轮Event Loop开始前执行的回调函数。因此，<code>process.nextTick</code>的回调函数会阻塞下一个Event Loop。所以，<code>process.nextTick</code>不能出现嵌套，否则会阻塞掉整个Event Loop，不过此时Node会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// performs complicated calculations continuously</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  process.nextTick(compute);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  res.end(<span class="string">'Hello World'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;).listen(<span class="number">5000</span>, <span class="string">'127.0.0.1'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">compute();</span></pre></td></tr></table></figure>

<p>上面代码中，服务器是不会响应HTTP请求的，因为嵌套的<code>process.nextTick</code>在网络I/O之前不断执行，不会结束。</p>
<p><code>process.nextTick</code>的一个应用是，确保回调函数异步执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncReal</span>(<span class="params">data, callback</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    callback(data === <span class="string">'foo'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中，即使<code>asyncReal</code>同步执行，<code>callback</code>也能确保是异步执行。</p>
<p>另一个用途是保证某些方法在初始化之后执行。下面是一个数据流的库文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StreamLibrary</span>(<span class="params">resourceName</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'start'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ... 从文件读取数据，然后触发data事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'data'</span>, chunkRead);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">StreamLibrary.prototype.__proto__ = EventEmitter.prototype;</span></pre></td></tr></table></figure>

<p>上面这样的写法，使用时根本不会监听到<code>start</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> StreamLibrary(<span class="string">'fooResource'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">stream.on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Reading has started'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received: '</span> + chunk);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码中，<code>start</code>事件是监听不到的。因为<code>StreamLibrary</code>一初始化时，就会触发<code>start</code>事件，这时根本还没指定回调函数。这就需要使用<code>process.nextTick</code>改写<code>StreamLibrary</code>库。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StreamLibrary</span>(<span class="params">resourceName</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    self.emit(<span class="string">'start'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ... 从文件读取数据，然后触发data事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'data'</span>, chunkRead);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码中，只有当前Event Loop的所有代码执行完，才会触发<code>start</code>事件，这就确保这个事件可以被监听到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>); &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>); &#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>); &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// output:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextTick</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// setImmediate</span></span></pre></td></tr></table></figure>

<p>上面的代码中，<code>process.nextTick</code>总是在<code>setTimeout</code>和<code>setImmediate</code>之前执行。这是因为<code>process.nextTick</code>是在本轮事件循环的末尾执行，而其他两个方法都是在下轮事件循环执行。所以，前者总是排在后者前面。</p>
<h2 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h2><p><code>setImmediate</code>方法用于指定在下一轮Event Loop立即执行的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">setImmediate(callback[, arg][, ...])</span></pre></td></tr></table></figure>

<p>它的第一个参数就是指定的回调函数，其他参数则会被传入回调函数。它返回一个对象，供<code>clearImmediate()</code>使用。</p>
<p><code>setImmediate</code>指定的回调函数，执行顺序是在I/O事件的回调函数之后，<code>setTimeout</code>和<code>setInterval</code>方法指定的回调函数（延迟时间非零的情况下）之前。</p>
<p>如果延迟时间为零，即<code>setImmediate</code>与<code>setTimeout(fn, 0)</code>哪个命令会先执行？答案是不确定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Timeout 0'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Immediate'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  x();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  y();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">10</span>);</span></pre></td></tr></table></figure>

<p>上面代码执行后，<code>Timeout 0</code>和<code>Immediate</code>都有可能首先输出。</p>
<p>考虑到<code>setImmediate</code>语义更清楚，行为更规范，建议总是使用它替代<code>setTimeout(fn, 0)</code>。</p>
<h2 id="clearImmediate"><a href="#clearImmediate" class="headerlink" title="clearImmediate()"></a>clearImmediate()</h2><p><code>clearImmediate</code>方法用于清除<code>setImmediate</code>设置的定时器。它的参数是<code>setImmediate</code>方法返回的定时器对象。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Kishore Nallan, <a href="http://howtonode.org/understanding-process-next-tick" target="_blank" rel="noopener">Understanding process.nextTick()</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-04-14 </div>
			<div class="article-title"><a href="/2017/04/14/2017-04-14-node-js-stream/" >stream 接口</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="Stream是什么？"><a href="#Stream是什么？" class="headerlink" title="Stream是什么？"></a>Stream是什么？</h2><p>”流“（stream）这个概念，最简单的理解，就是在数据还没有接收完成时，就开始处理它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'./data/customers.csv'</span>).pipe(process.stdout);</span></pre></td></tr></table></figure>

<p>上面代码中，<code>fs.createReadStream</code>方法以”流“的方式读取文件，这可以在文件还没有读取完的情况下，就输出到标准输出。这显然对大文件的读取非常有利。</p>
<p>Unix操作系统从很早以前，就有Stream（流）这个概念，它是不同进程之间传递数据的一种方式。管道命令Pipe就起到在不同命令之间，连接Stream的作用。</p>
<p>Stream把较大的数据，拆成很小的部分。只要命令部署了Stream接口，就可以把一个流的输出接到另一个流的输入。Node引入了这个概念，通过Stream为异步读写数据提供的统一接口。无论是硬盘数据、网络数据，还是内存数据，都可以采用这个接口读写。</p>
<p>读写数据有两种方式。一种方式是同步处理，即先将数据全部读入内存，然后处理。它的优点是符合直觉，流程非常自然，缺点是如果遇到大文件，要花很长时间，可能要过很久才能进入数据处理的步骤。另一种方式就是Stream方式，它是系统读取外部数据实际上的方式，即每次只读入数据的一小块，像“流水”一样。所以，Stream方式就是每当系统读入了一小块数据，就会触发一个事件，发出“新数据块”的信号，只要监听这个事件，就能掌握进展，做出相应处理，这样就提高了程序的性能。</p>
<p>Stream接口最大特点就是通过事件通信，具有readable、writable、drain、data、end、close等事件，既可以读取数据，也可以写入数据。读写数据时，每读入（或写入）一段数据，就会触发一次data事件，全部读取（或写入）完毕，触发end事件。如果发生错误，则触发error事件。</p>
<p>一个对象只要部署了Stream接口，就可以从读取数据，或者写入数据。Node内部很多涉及IO处理的对象，都部署了Stream接口，比如HTTP连接、文件读写、标准输入输出等。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>Node的I/O操作都是异步的，所以与磁盘和网络的交互，都要通过回调函数。一个典型的写文件操作，可能像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    res.end(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">server.listen(<span class="number">8000</span>);</span></pre></td></tr></table></figure>

<p>上面的代码有一个问题，那就是它必须将整个data.txt文件读入内存，然后再输入。如果data.txt非常大，就会占用大量的内容。一旦有多个并发请求，操作就会变得非常缓慢，用户不得不等很久，才能得到结果。</p>
<p>由于参数req和res都部署了Stream接口，可以使用<code>fs.createReadStream()</code>替代<code>fs.readFile()</code>，就能解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  stream.pipe(res);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">server.listen(<span class="number">8000</span>);</span></pre></td></tr></table></figure>

<p>Stream接口的最大特点，就是数据会发出node和data事件，内置的pipe方法会处理这两个事件。</p>
<p>数据流通过pipe方法，可以方便地导向其他具有Stream接口的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'wow.txt'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  .pipe(zlib.createGzip())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  .pipe(process.stdout);</span></pre></td></tr></table></figure>

<p>上面代码先打开文本文件wow.txt，然后压缩，再导向标准输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'wow.txt'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  .pipe(zlib.createGzip())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  .pipe(fs.createWriteStream(<span class="string">'wow.gz'</span>));</span></pre></td></tr></table></figure>

<p>上面代码压缩文件wow.txt以后，又将其写回压缩文件。</p>
<p>下面代码新建一个Stream实例，然后指定写入事件和终止事件的回调函数，再将其接到标准输入之上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Stream = stream.Stream;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> Stream;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ws.writable = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ws.write = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"input="</span> + data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">ws.end = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"bye"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">process.stdin.pipe(ws);</span></pre></td></tr></table></figure>

<p>调用上面的脚本，会产生以下结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ node pipe_out.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hello</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">input=hello</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">^d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">bye</span></span></pre></td></tr></table></figure>

<p>上面代码调用脚本下，键入hello，会输出<code>input=hello</code>。然后按下ctrl-d，会输出bye。使用管道命令，可以看得更清楚。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello | node pipe_out.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">input=hello</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">bye</span></span></pre></td></tr></table></figure>

<p>Stream接口分成三类。</p>
<ul>
<li>可读数据流接口，用于读取数据。</li>
<li>可写数据流接口，用于写入数据。</li>
<li>双向数据流接口，用于读取和写入数据，比如Node的tcp sockets、zlib、crypto都部署了这个接口。</li>
</ul>
<h2 id="可读数据流"><a href="#可读数据流" class="headerlink" title="可读数据流"></a>可读数据流</h2><p>“可读数据流”用来产生数据。它表示数据的来源，只要一个对象提供“可读数据流”，就表示你可以从其中读取数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = <span class="keyword">new</span> Readable();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">rs.push(<span class="string">'beep '</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">rs.push(<span class="string">'boop\n'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">rs.push(<span class="literal">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">rs.pipe(process.stdout);</span></pre></td></tr></table></figure>

<p>上面代码产生了一个可写数据流，最后将其写入标注输出。可读数据流的push方法，用来将数据输入缓存。<br><code>rs.push(null)</code>中的null，用来告诉rs，数据输入完毕。</p>
<p>“可读数据流”有两种状态：流动态和暂停态。处于流动态时，数据会尽快地从数据源导向用户的程序；处于暂停态时，必须显式调用<code>stream.read()</code>等指令，“可读数据流”才会释放数据。刚刚新建的时候，“可读数据流”处于暂停态。</p>
<p>三种方法可以让暂停态转为流动态。</p>
<ul>
<li>添加data事件的监听函数</li>
<li>调用resume方法</li>
<li>调用pipe方法将数据送往一个可写数据流</li>
</ul>
<p>如果转为流动态时，没有data事件的监听函数，也没有pipe方法的目的地，那么数据将遗失。</p>
<p>以下两种方法可以让流动态转为暂停态。</p>
<ul>
<li>不存在pipe方法的目的地时，调用pause方法</li>
<li>存在pipe方法的目的地时，移除所有data事件的监听函数，并且调用unpipe方法，移除所有pipe方法的目的地</li>
</ul>
<p>注意，只移除data事件的监听函数，并不会自动引发数据流进入“暂停态”。另外，存在pipe方法的目的地时，调用pause方法，并不能保证数据流总是处于暂停态，一旦那些目的地发出数据请求，数据流有可能会继续提供数据。</p>
<p>每当系统有新的数据，该接口可以监听到data事件，从而回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">readableStream.setEncoding(<span class="string">'utf8'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  data+=chunk;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码中，fs模块的createReadStream方法，是部署了Stream接口的文件读取方法。该方法对指定的文件，返回一个对象。该对象只要监听data事件，回调函数就能读到数据。</p>
<p>除了data事件，监听readable事件，也可以读到数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunk;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">readableStream.setEncoding(<span class="string">'utf8'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">readableStream.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> ((chunk=readableStream.read()) !== <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    data += chunk;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">readableStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>readable事件表示系统缓冲之中有可读的数据，使用read方法去读出数据。如果没有数据可读，read方法会返回null。</p>
<p>“可读数据流”除了read方法，还有以下方法。</p>
<ul>
<li>Readable.pause() ：暂停数据流。已经存在的数据，也不再触发data事件，数据将保留在缓存之中，此时的数据流称为静态数据流。如果对静态数据流再次调用pause方法，数据流将重新开始流动，但是缓存中现有的数据，不会再触发data事件。</li>
<li>Readable.resume()：恢复暂停的数据流。</li>
<li>readable.unpipe()：从管道中移除目的地数据流。如果该方法使用时带有参数，会阻止“可读数据流”进入某个特定的目的地数据流。如果使用时不带有参数，则会移除所有的目的地数据流。</li>
</ul>
<h3 id="readable-属性"><a href="#readable-属性" class="headerlink" title="readable 属性"></a>readable 属性</h3><p>一个数据流的<code>readable</code>属性返回一个布尔值。如果数据流是一个仍然打开的可读数据流，就返回<code>true</code>，否则返回<code>false</code>。</p>
<h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>read方法从系统缓存读取并返回数据。如果读不到数据，则返回null。</p>
<p>该方法可以接受一个整数作为参数，表示所要读取数据的数量，然后会返回该数量的数据。如果读不到足够数量的数据，返回null。如果不提供这个参数，默认返回系统缓存之中的所有数据。</p>
<p>只在“暂停态”时，该方法才有必要手动调用。“流动态”时，该方法是自动调用的，直到系统缓存之中的数据被读光。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> chunk;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> (<span class="literal">null</span> !== (chunk = readable.read())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'got %d bytes of data'</span>, chunk.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>如果该方法返回一个数据块，那么它就触发了data事件。</p>
<h3 id="read-1"><a href="#read-1" class="headerlink" title="_read()"></a>_read()</h3><p>可读数据流的<code>_read</code>方法，可以将数据放入可读数据流。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = Readable();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">97</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">rs._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  rs.push(<span class="built_in">String</span>.fromCharCode(c++));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (c &gt; <span class="string">'z'</span>.charCodeAt(<span class="number">0</span>)) rs.push(<span class="literal">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">rs.pipe(process.stdout);</span></pre></td></tr></table></figure>

<p>运行结果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ node read1.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz</span></pre></td></tr></table></figure>

<h3 id="setEncoding"><a href="#setEncoding" class="headerlink" title="setEncoding()"></a>setEncoding()</h3><p>调用该方法，会使得数据流返回指定编码的字符串，而不是缓存之中的二进制对象。比如，调用<code>setEncoding(&#39;utf8&#39;)</code>，数据流会返回UTF-8字符串，调用<code>setEncoding(&#39;hex&#39;)</code>，数据流会返回16进制的字符串。</p>
<p><code>setEncoding</code>的参数是字符串的编码方法，比如<code>utf8</code>、<code>ascii</code>、<code>base64</code>等。</p>
<p>该方法会正确处理多字节的字符，而缓存的方法<code>buf.toString(encoding)</code>不会。所以如果想要从数据流读取字符串，应该总是使用该方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">readable.setEncoding(<span class="string">'utf8'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  assert.equal(<span class="keyword">typeof</span> chunk, <span class="string">'string'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got %d characters of string data'</span>, chunk.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h3 id="resume"><a href="#resume" class="headerlink" title="resume()"></a>resume()</h3><p><code>resume</code>方法会使得“可读数据流”继续释放<code>data</code>事件，即转为流动态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个readable数据流</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">readable.resume();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'数据流到达尾部，未读取任务数据'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码中，调用<code>resume</code>方法使得数据流进入流动态，只定义<code>end</code>事件的监听函数，不定义<code>data</code>事件的监听函数，表示不从数据流读取任何数据，只监听数据流到达尾部。</p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause()"></a>pause()</h3><p><code>pause</code>方法使得流动态的数据流，停止释放<code>data</code>事件，转而进入暂停态。任何此时已经可以读到的数据，都将停留在系统缓存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个readable数据流</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取%d字节的数据'</span>, chunk.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  readable.pause();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'接下来的1秒内不读取数据'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据恢复读取'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    readable.resume();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;, <span class="number">1000</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h3 id="isPaused"><a href="#isPaused" class="headerlink" title="isPaused()"></a>isPaused()</h3><p>该方法返回一个布尔值，表示“可读数据流”被客户端手动暂停（即调用了pause方法），目前还没有调用resume方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = <span class="keyword">new</span> stream.Readable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">readable.isPaused() <span class="comment">// === false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">readable.pause()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">readable.isPaused() <span class="comment">// === true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">readable.resume()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">readable.isPaused() <span class="comment">// === false</span></span></pre></td></tr></table></figure>

<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h3><p>pipe方法是自动传送数据的机制，就像管道一样。它从“可读数据流”读出所有数据，将其写出指定的目的地。整个过程是自动的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">src.pipe(dst)</span></pre></td></tr></table></figure>

<p>pipe方法必须在可读数据流上调用，它的参数必须是可写数据流。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file1.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writableStream = fs.createWriteStream(<span class="string">'file2.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">readableStream.pipe(writableStream);</span></pre></td></tr></table></figure>

<p>上面代码使用pipe方法，将file1的内容写入file2。整个过程由pipe方法管理，不用手动干预，所以可以将传送数据写得很简洁。</p>
<p>pipe方法返回目的地的数据流，因此可以使用链式写法，将多个数据流操作连在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">a.pipe(b).pipe(c).pipe(d)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">a.pipe(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">b.pipe(c);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">c.pipe(d);</span></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'input.txt.gz'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  .pipe(zlib.createGunzip())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  .pipe(fs.createWriteStream(<span class="string">'output.txt'</span>));</span></pre></td></tr></table></figure>

<p>上面代码采用链式写法，先读取文件，然后进行压缩，最后输出。</p>
<p>下面的写法模拟了Unix系统的cat命令，将标准输出写入标准输入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.stdin.pipe(process.stdout);</span></pre></td></tr></table></figure>

<p>当来源地的数据流读取完成，默认会调用目的地的end方法，就不再能够写入。对pipe方法传入第二个参数<code>{ end: false }</code>，可以让目的地的数据流保持打开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">reader.pipe(writer, &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">reader.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  writer.end(<span class="string">'Goodbye\n'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码中，目的地数据流默认不会调用end方法，只能手动调用，因此“Goodbye”会被写入。</p>
<h3 id="unpipe"><a href="#unpipe" class="headerlink" title="unpipe()"></a>unpipe()</h3><p>该方法移除pipe方法指定的数据流目的地。如果没有参数，则移除所有的pipe方法目的地。如果有参数，则移除该参数指定的目的地。如果没有匹配参数的目的地，则不会产生任何效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writable = fs.createWriteStream(<span class="string">'file.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">readable.pipe(writable);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'停止写入file.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  readable.unpipe(writable);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'手动关闭file.txt的写入数据流'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  writable.end();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">1000</span>);</span></pre></td></tr></table></figure>

<p>上面代码写入file.txt的时间，只有1秒钟，然后就停止写入。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>下面代码中，<code>s</code>是一个readable数据流，它可以监听以下事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">s.on(&#39;data&#39;, f);    &#x2F;&#x2F; 收到新的数据时，data事件就会发生，触发f()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s.on(&#39;end&#39;, f);     &#x2F;&#x2F; 数据读取完以后，不会再收到数据了，end事件发生，触发f()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">s.on(&#39;error&#39;, f);   &#x2F;&#x2F; 发生错误时，error事件发生，触发f()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">s.readable          &#x2F;&#x2F; &#x3D;&gt; true if it is a readable stream that is still open</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">s.pause();          &#x2F;&#x2F; Pause &quot;data&quot; events.  For throttling uploads, e.g.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">s.resume();         &#x2F;&#x2F; Resume again</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">（1）readable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">readable事件在数据流能够向外提供数据时触发。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;javascript</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">var readable &#x3D; getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">readable.on(&#39;readable&#39;, function() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; there is some data to read now</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> buf = process.stdin.read();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.dir(buf);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码将标准输入的数据读出。</p>
<p>read方法接受一个整数作为参数，表示以多少个字节为单位进行读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> buf = process.stdin.read(<span class="number">3</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.dir(buf);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码将以3个字节为单位进行输出内容。</p>
<p>（2）data</p>
<p>对于那些没有显式暂停的数据流，添加data事件监听函数，会将数据流切换到流动态，尽快向外提供数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got %d bytes of data'</span>, chunk.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>（3）end</p>
<p>无法再读取到数据时，会触发end事件。也就是说，只有当前数据被完全读取完，才会触发end事件，比如不停地调用read方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readable = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got %d bytes of data'</span>, chunk.length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'there will be no more data.'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>（4）close</p>
<p>数据源关闭时，close事件被触发。并不是所有的数据流都支持这个事件。</p>
<p>（5）error</p>
<p>当读取数据发生错误时，error事件被触发。</p>
<h2 id="可写数据流"><a href="#可写数据流" class="headerlink" title="可写数据流"></a>可写数据流</h2><p>“可写数据流”允许你将数据写入某个目的地。它是数据写入的一种抽象，不同的数据目的地部署了这个接口以后，就可以用统一的方法写入。</p>
<p>以下是部署了可写数据流的一些场合。</p>
<ul>
<li>客户端的http requests</li>
<li>服务器的http responses</li>
<li>fs write streams</li>
<li>zlib streams</li>
<li>crypto streams</li>
<li>tcp sockets</li>
<li>child process stdin</li>
<li>process.stdout, process.stderr</li>
</ul>
<p>下面是fs模块的可写数据流的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readableStream = fs.createReadStream(<span class="string">'file1.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writableStream = fs.createWriteStream(<span class="string">'file2.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">readableStream.setEncoding(<span class="string">'utf8'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">readableStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  writableStream.write(chunk);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码中，fs模块的<code>createWriteStream</code>方法针对特定文件，创建了一个“可写数据流”，本质上就是对写入操作部署了<code>Stream</code>接口。然后，“可写数据流”的<code>write</code>方法，可以将数据写入文件。</p>
<h3 id="writable属性"><a href="#writable属性" class="headerlink" title="writable属性"></a>writable属性</h3><p><code>writable</code>属性返回一个布尔值。如果数据流仍然打开，并且可写，就返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">s.writeable</span></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h3><p><code>write</code>方法用于向“可写数据流”写入数据。它接受两个参数，一个是写入的内容，可以是字符串，也可以是一个<code>stream</code>对象（比如可读数据流）或<code>buffer</code>对象（表示二进制数据），另一个是写入完成后的回调函数，它是可选的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">s.write(buffer);          <span class="comment">// 写入二进制数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s.write(string, encoding) <span class="comment">// 写入字符串，编码默认为utf-8</span></span></pre></td></tr></table></figure>

<p><code>write</code>方法返回一个布尔值，表示本次数据是否处理完成。如果返回<code>true</code>，就表示可以写入新的数据了。如果等待写入的数据被缓存了，就返回<code>false</code>，表示此时不能立刻写入新的数据。不过，返回<code>false</code>的情况下，也可以继续传入新的数据等待写入。只是这时，新的数据不会真的写入，只会缓存在内存中。为了避免内存消耗，比较好的做法还是等待该方法返回<code>true</code>，然后再写入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'message.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ws.write(<span class="string">'beep '</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  ws.end(<span class="string">'boop\n'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">1000</span>);</span></pre></td></tr></table></figure>

<p>上面代码调用end方法，数据就不再写入了。</p>
<h3 id="cork-，uncork"><a href="#cork-，uncork" class="headerlink" title="cork()，uncork()"></a>cork()，uncork()</h3><p>cork方法可以强制等待写入的数据进入缓存。当调用uncork方法或end方法时，缓存的数据就会吐出。</p>
<h3 id="setDefaultEncoding"><a href="#setDefaultEncoding" class="headerlink" title="setDefaultEncoding()"></a>setDefaultEncoding()</h3><p>setDefaultEncoding方法用于将写入的数据编码成新的格式。它返回一个布尔值，表示编码是否成功，如果返回false就表示编码失败。</p>
<h3 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h3><p><code>end</code>方法用于终止“可写数据流”。该方法可以接受三个参数，全部都是可选参数。第一个参数是最后所要写入的数据，可以是字符串，也可以是<code>stream</code>对象或<code>buffer</code>对象；第二个参数是写入编码；第三个参数是一个回调函数，<code>finish</code>事件发生时，会触发这个回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">s.end()                  <span class="comment">// 关闭可写数据流</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">s.end(buffer)            <span class="comment">// 最后一段写入二进制数据，然后关闭可写数据流</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">s.end(str, encoding)     <span class="comment">// 最后一段写入字符串，然后关闭可写数据流</span></span></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = fs.createWriteStream(<span class="string">'example.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">file.write(<span class="string">'hello, '</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">file.end(<span class="string">'world!'</span>);</span></pre></td></tr></table></figure>

<p>上面代码会在数据写入结束时，在尾部写入“world！”。</p>
<p>调用end方法之后，再写入数据会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = fs.createWriteStream(<span class="string">'example.txt'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">file.end(<span class="string">'world!'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">file.write(<span class="string">'hello, '</span>); <span class="comment">// 报错</span></span></pre></td></tr></table></figure>

<h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><p>（1）drain事件</p>
<p><code>writable.write(chunk)</code>返回<code>false</code>以后，当缓存数据全部写入完成，可以继续写入时，会触发<code>drain</code>事件，表示缓存空了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">s.on(<span class="string">'drain'</span>, f);</span></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeOneMillionTimes</span>(<span class="params">writer, data, encoding, callback</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> i = <span class="number">1000000</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  write();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> ok = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      i -= <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        writer.write(data, encoding, callback);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        ok = writer.write(data, encoding);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; ok);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      writer.once(<span class="string">'drain'</span>, write);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码是一个写入100万次的例子，通过drain事件得到可以继续写入的通知。</p>
<p>（2）finish事件</p>
<p>调用end方法时，所有缓存的数据释放，触发finish事件。该事件的回调函数没有参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writer = getWritableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  writer.write(<span class="string">'hello, #'</span> + i + <span class="string">'!\n'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">writer.end(<span class="string">'this is the end\n'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">writer.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.error(<span class="string">'all writes are now complete.'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>（3）pipe事件</p>
<p>“可写数据流”调用pipe方法，将数据流导向写入目的地时，触发该事件。</p>
<p>该事件的回调函数，接受发出该事件的“可读数据流”对象作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writer = getWritableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">writer.on(<span class="string">'pipe'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.error(<span class="string">'something is piping into the writer'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  assert.equal(src, reader);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">reader.pipe(writer);</span></pre></td></tr></table></figure>

<p>（4）unpipe事件</p>
<p>“可读数据流”调用unpipe方法，将可写数据流移出写入目的地时，触发该事件。</p>
<p>该事件的回调函数，接受发出该事件的“可读数据流”对象作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writer = getWritableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = getReadableStreamSomehow();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">writer.on(<span class="string">'unpipe'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.error(<span class="string">'something has stopped piping into the writer'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  assert.equal(src, reader);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">reader.pipe(writer);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">reader.unpipe(writer);</span></pre></td></tr></table></figure>

<p>（5）error事件</p>
<p>如果写入数据或pipe数据时发生错误，就会触发该事件。</p>
<p>该事件的回调函数，接受一个Error对象作为参数。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>HTTP对象使用Stream接口，实现网络数据的读写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// req is an http.IncomingMessage, which is a Readable Stream</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// res is an http.ServerResponse, which is a Writable Stream</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> body = <span class="string">''</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// we want to get the data as utf8 strings</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// If you don't set an encoding, then you'll get Buffer objects</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  req.setEncoding(<span class="string">'utf8'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Readable streams emit 'data' events once a listener is added</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    body += chunk;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// the end event tells you that you have entire body</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(body);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (er) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// uh oh!  bad json!</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      res.statusCode = <span class="number">400</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> res.end(<span class="string">'error: '</span> + er.message);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// write back something interesting to the user:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    res.write(<span class="keyword">typeof</span> data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    res.end();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">server.listen(<span class="number">1337</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// $ curl localhost:1337 -d '&#123;&#125;'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// object</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// $ curl localhost:1337 -d '"foo"'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// $ curl localhost:1337 -d 'not json'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: Unexpected token o</span></span></pre></td></tr></table></figure>

<p>data事件表示读取或写入了一块数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">buf</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Do something with the Buffer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>使用req.setEncoding方法，可以设定字符串编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">req.setEncoding(<span class="string">'utf8'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Do something with the String</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>end事件，表示读取或写入数据完毕。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    res.writeHead(<span class="number">200</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        res.write(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        res.end();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;).listen(<span class="number">3000</span>);</span></pre></td></tr></table></figure>

<p>上面代码相当于建立了“回声”服务，将HTTP请求的数据体，用HTTP回应原样发送回去。</p>
<p>system模块提供了pump方法，有点像Linux系统的管道功能，可以将一个数据流，原封不动得转给另一个数据流。所以，上面的例子也可以用pump方法实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    sys = <span class="built_in">require</span>(<span class="string">'sys'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    res.writeHead(<span class="number">200</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    sys.pump(req, res);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;).listen(<span class="number">3000</span>);</span></pre></td></tr></table></figure>

<h2 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h2><p>fs模块的createReadStream方法用于新建读取数据流，createWriteStream方法用于新建写入数据流。使用这两个方法，可以做出一个用于文件复制的脚本copy.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.argv[<span class="number">2</span>], <span class="string">'-&gt;'</span>, process.argv[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(process.argv[<span class="number">2</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(process.argv[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  writeStream.write(chunk);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  writeStream.end();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">readStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"ERROR"</span>, err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">writeStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"ERROR"</span>, err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;);d all your errors, you wouldn<span class="string">'t need to use domains.</span></span></pre></td></tr></table></figure>

<p>上面代码非常容易理解，使用的时候直接提供源文件路径和目标文件路径，就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">node cp.js src.txt dest.txt</span></pre></td></tr></table></figure>

<p>Streams对象都具有pipe方法，起到管道作用，将一个数据流输入另一个数据流。所以，上面代码可以重写成下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.argv[<span class="number">2</span>], <span class="string">'-&gt;'</span>, process.argv[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(process.argv[<span class="number">2</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(process.argv[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">readStream.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  readStream.pipe(writeStream);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  writeStream.end();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>下面是压缩后发送文件的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// set the content headers</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  fs.createReadStream(<span class="string">'filename.txt'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  .pipe(zlib.createGzip())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  .pipe(res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>上面的代码没有部署错误处理机制，一旦发生错误，就无法处理。所以，需要加上error事件的监听函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// set the content headers</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  fs.createReadStream(<span class="string">'filename.txt'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  .on(<span class="string">'error'</span>, onerror)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  .pipe(zlib.createGzip())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  .on(<span class="string">'error'</span>, onerror)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  .pipe(res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onerror</span>(<span class="params">err</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.error(err.stack)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>上面的代码还是存在问题，如果客户端中断下载，写入的数据流就会收不到close事件，一直处于等待状态，从而造成内存泄漏。因此，需要使用<a href="https://github.com/jshttp/on-finished" target="_blank" rel="noopener">on-finished模块</a>用来处理这种情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> stream = fs.createReadStream(<span class="string">'filename.txt'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// set the content headers</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  stream</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  .on(<span class="string">'error'</span>, onerror)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  .pipe(zlib.createGzip())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  .on(<span class="string">'error'</span>, onerror)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  .pipe(res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  onFinished(res, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// make sure the stream is always destroyed</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    stream.destroy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>James Halliday, <a href="https://github.com/substack/cs294-101-streams-lecture" target="_blank" rel="noopener">cs294-101-streams-lecture</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-04-14 </div>
			<div class="article-title"><a href="/2017/04/14/2017-04-14-node-js-repl/" >repl 模块</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>repl</code>模块用于在程序内提供REPL在线环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repl = <span class="built_in">require</span>(<span class="string">'repl'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">i</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> context = repl.start(<span class="string">'repl&gt; '</span>).context;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  context.pi  = <span class="number">3.14</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  context.arg = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">a(<span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// repl&gt; pi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.14</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// repl&gt; arg</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// repl&gt;</span></span></pre></td></tr></table></figure>

<p>上面代码通过<code>repl.start</code>方法，启动REPL环境。<code>repl.start</code>方法还可以通过参数，定制提示符。REPL实例对象的<code>context</code>对象的属性，可以在REPL环境内读取。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-04-14 </div>
			<div class="article-title"><a href="/2017/04/14/2017-04-14-node-js-process/" >process 对象</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><code>process</code> 对象是 <code>Node</code> 的一个全局对象，提供当前Node进程的信息。它可以在脚本的任意位置使用，不必通过 <code>require</code>命令加载。该对象部署了 <code>EventEmitter</code> 接口。</p>
<h2 id="进程的退出码"><a href="#进程的退出码" class="headerlink" title="进程的退出码"></a>进程的退出码</h2><p>进程退出时，会返回一个整数值，表示退出时的状态。这个整数值就叫做退出码。下面是常见的 <code>Node</code> 进程退出码。</p>
<ul>
<li>0，正常退出</li>
<li>1，发生未捕获错误</li>
<li>5，V8执行错误</li>
<li>8，不正确的参数</li>
<li>128 + 信号值，如果Node接受到退出信号（比如SIGKILL或SIGHUP），它的退出码就是128加上信号值。由于128的二进制形式是 10000000, 所以退出码的后七位就是信号值。</li>
</ul>
<p>Bash可以使用环境变量<code>$?</code>，获取上一步操作的退出码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ node nonexist.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Error: Cannot find <span class="string">'nonexist.js'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">1</span></pre></td></tr></table></figure>

<p>上面代码中，Node执行一个不存在的脚本文件，结果报错，退出码就是1。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>process对象提供一系列属性，用于返回系统信息。</p>
<ul>
<li><strong>process.argv</strong>：返回当前进程的命令行参数数组。</li>
<li><strong>process.env</strong>：返回一个对象，成员为当前Shell的环境变量，比如<code>process.env.HOME</code>。</li>
<li><strong>process.installPrefix</strong>：node的安装路径的前缀，比如<code>/usr/local</code>，则node的执行文件目录为<code>/usr/local/bin/node</code>。</li>
<li><strong>process.pid</strong>：当前进程的进程号。</li>
<li><strong>process.platform</strong>：当前系统平台，比如Linux。</li>
<li><strong>process.title</strong>：默认值为“node”，可以自定义该值。</li>
<li><strong>process.version</strong>：Node的版本，比如v0.10.18。</li>
</ul>
<p>下面是主要属性的介绍。</p>
<h3 id="stdout，stdin，stderr"><a href="#stdout，stdin，stderr" class="headerlink" title="stdout，stdin，stderr"></a>stdout，stdin，stderr</h3><p>以下属性指向系统I/O。</p>
<p><strong>（1）stdout</strong></p>
<p>stdout属性指向标准输出（文件描述符1）。它的write方法等同于console.log，可用在标准输出向用户显示内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  process.stdout.write(d + <span class="string">'\n'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>下面代码表示将一个文件导向标准输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'wow.txt'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  .pipe(process.stdout);</span></pre></td></tr></table></figure>

<p>上面代码中，由于process.stdout和process.stdin与其他进程的通信，都是流（stream）形式，所以必须通过 <code>pipe</code> 管道命令中介。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'wow.txt'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  .pipe(zlib.createGzip())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  .pipe(process.stdout);</span></pre></td></tr></table></figure>

<p>上面代码通过pipe方法，先将文件数据压缩，然后再导向标准输出。</p>
<p><strong>（2）stdin</strong></p>
<p>stdin代表标准输入（文件描述符0）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.stdin.pipe(process.stdout)</span></pre></td></tr></table></figure>

<p>上面代码表示将标准输入导向标准输出。</p>
<p>由于stdin和stdout都部署了stream接口，所以可以使用stream接口的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">'utf8'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    process.stdout.write(<span class="string">'data: '</span> + chunk);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  process.stdout.write(<span class="string">'end'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><strong>（3）stderr</strong></p>
<p>stderr属性指向标准错误（文件描述符2）。</p>
<h3 id="argv，execPath，execArgv"><a href="#argv，execPath，execArgv" class="headerlink" title="argv，execPath，execArgv"></a>argv，execPath，execArgv</h3><p>argv属性返回一个数组，由命令行执行脚本时的各个参数组成。<strong>它的第一个成员总是 <code>node</code>，第二个成员是脚本文件名，其余成员是脚本文件的参数。</strong></p>
<p>请看下面的例子，新建一个脚本文件argv.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// argv.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"argv: "</span>,process.argv);</span></pre></td></tr></table></figure>

<p>在命令行下调用这个脚本，会得到以下结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ node argv.js a b c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[ <span class="string">'node'</span>, <span class="string">'/path/to/argv.js'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> ]</span></pre></td></tr></table></figure>

<p>上面代码表示，argv返回数组的成员依次是命令行的各个部分，真正的参数实际上是从<code>process.argv[2]</code>开始。要得到真正的参数部分，可以把argv.js改写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// argv.js</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArgs = process.argv.slice(<span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myArgs);</span></pre></td></tr></table></figure>

<p>execPath属性返回执行当前脚本的Node二进制文件的绝对路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; process.execPath</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">'/usr/local/bin/node'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt;</span></pre></td></tr></table></figure>

<p>execArgv属性返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># script.js的代码为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># console.log(process.execArgv);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ node --harmony script.js --version</span></pre></td></tr></table></figure>

<h3 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h3><p><code>process.env</code>属性返回一个对象，包含了当前Shell的所有环境变量。比如，<code>process.env.HOME</code>返回用户的主目录。</p>
<p>通常的做法是，新建一个环境变量<code>NODE_ENV</code>，用它确定当前所处的开发阶段，生产阶段设为<code>production</code>，开发阶段设为<code>develop</code>或<code>staging</code>，然后在脚本中读取<code>process.env.NODE_ENV</code>即可。</p>
<p>运行脚本时，改变环境变量，可以采用下面的写法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> NODE_ENV=production &amp;&amp; node app.js</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production node app.js</span></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>process对象提供以下方法：</p>
<ul>
<li><strong>process.chdir()</strong>：切换工作目录到指定目录。</li>
<li><strong>process.cwd()</strong>：返回运行当前脚本的工作目录的路径。</li>
<li><strong>process.exit()</strong>：退出当前进程。</li>
<li><strong>process.getgid()</strong>：返回当前进程的组ID（数值）。</li>
<li><strong>process.getuid()</strong>：返回当前进程的用户ID（数值）。</li>
<li><strong>process.nextTick()</strong>：指定回调函数在当前执行栈的尾部、下一次Event Loop之前执行。</li>
<li><strong>process.on()</strong>：监听事件。</li>
<li><strong>process.setgid()</strong>：指定当前进程的组，可以使用数字ID，也可以使用字符串ID。</li>
<li><strong>process.setuid()</strong>：指定当前进程的用户，可以使用数字ID，也可以使用字符串ID。</li>
</ul>
<h3 id="process-cwd-，process-chdir"><a href="#process-cwd-，process-chdir" class="headerlink" title="process.cwd()，process.chdir()"></a>process.cwd()，process.chdir()</h3><p><code>cwd</code>方法返回进程的当前目录（绝对路径），<code>chdir</code>方法用来切换目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; process.cwd()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">'/home/aaa'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt; process.chdir(<span class="string">'/home/bbb'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&gt; process.cwd()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">'/home/bbb'</span></span></pre></td></tr></table></figure>

<p>注意，<code>process.cwd()</code>与<code>__dirname</code>的区别。前者进程发起时的位置，后者是脚本的位置，两者可能是不一致的。比如，<code>node ./code/program.js</code>，对于<code>process.cwd()</code>来说，返回的是当前目录（<code>.</code>）；对于<code>__dirname</code>来说，返回是脚本所在目录，即<code>./code/program.js</code>。</p>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h2><p><code>process.nextTick</code>将任务放到当前一轮事件循环（Event Loop）的尾部。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="title">function</span></span> () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(<span class="string">'下一次Event Loop即将开始!'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码可以用<code>setTimeout(f,0)</code>改写，效果接近，但是原理不同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  console.log(<span class="string">'已经到了下一轮Event Loop！'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;, 0)</span></pre></td></tr></table></figure>

<p><code>setTimeout(f,0)</code>是将任务放到下一轮事件循环的头部，因此<code>nextTick</code>会比它先执行。另外，<code>nextTick</code>的效率更高，因为不用检查是否到了指定时间。</p>
<p>根据Node的事件循环的实现，基本上，进入下一轮事件循环后的执行顺序如下。</p>
<ol>
<li><code>setTimeout(f,0)</code></li>
<li>各种到期的回调函数</li>
<li><code>process.nextTick</code><br>push(), sort(), reverse(), and splice() <h3 id="process-exit"><a href="#process-exit" class="headerlink" title="process.exit()"></a>process.exit()</h3></li>
</ol>
<p><code>process.exit</code>方法用来退出当前进程。它可以接受一个数值参数，如果参数大于0，表示执行失败；如果等于0表示执行成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  process.exit(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  process.exit(0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>process.exit()</code>执行时，会触发<code>exit</code>事件。</p>
<h3 id="process-on"><a href="#process-on" class="headerlink" title="process.on()"></a>process.on()</h3><p><code>process</code>对象部署了EventEmitter接口，可以使用<code>on</code>方法监听各种事件，并指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got an error: %s'</span>, err.message);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  process.exit(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">100</span>);</span></pre></td></tr></table></figure>

<p>上面代码是<code>process</code>监听Node的一个全局性事件<code>uncaughtException</code>，只要有错误没有捕获，就会触发这个事件。</p>
<p><code>process</code>支持的事件还有下面这些。</p>
<ul>
<li><code>data</code>事件：数据输出输入时触发</li>
<li><code>SIGINT</code>事件：接收到系统信号<code>SIGINT</code>时触发，主要是用户按<code>Ctrl + c</code>时触发。</li>
<li><code>SIGTERM</code>事件：系统发出进程终止信号<code>SIGTERM</code>时触发</li>
<li><code>exit</code>事件：进程退出前触发</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'SIGINT'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got a SIGINT. Goodbye cruel world'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  process.exit(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以忽略这个信号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'SIGINT'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Ignored Ctrl-C"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>使用时，向该进程发出系统信号，就会导致进程退出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -s SIGINT [process_id]</span></pre></td></tr></table></figure>

<p><code>SIGTERM</code>信号表示内核要求当前进程停止，进程可以自行停止，也可以忽略这个信号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  server.close(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    process.exit(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码表示，进程接到<code>SIGTERM</code>信号之后，关闭服务器，然后退出进程。需要注意的是，这时进程不会马上退出，而是要回应完最后一个请求，处理完所有回调函数，然后再退出。</p>
<p><code>exit</code>事件在Node进程退出前触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Goodbye'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h3 id="process-kill"><a href="#process-kill" class="headerlink" title="process.kill()"></a>process.kill()</h3><p>process.kill方法用来对指定ID的线程发送信号，默认为SIGINT信号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'terminating'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    process.exit(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sending SIGTERM to process %d'</span>, process.pid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    process.kill(process.pid, <span class="string">'SIGTERM'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">500</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'never called'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">1000</span>);</span></pre></td></tr></table></figure>

<p>上面代码中，500毫秒后向当前进程发送SIGTERM信号（终结进程），因此1000毫秒后的指定事件不会被触发。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h3><p>当前进程退出时，会触发<code>exit</code>事件，可以对该事件指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  fs.writeFileSync(<span class="string">'/tmp/myfile'</span>, <span class="string">'需要保存到硬盘的信息'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>下面是一个例子，进程退出时，显示一段日志。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">"exit"</span>, code =&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"exiting with code: "</span> + code))</span></pre></td></tr></table></figure>

<p><code>注意，此时回调函数只能执行同步操作，不能包含异步操作，因为执行完回调函数，进程就会退出，无法监听到回调函数的操作结果。</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 不会执行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'This will not run'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码在<code>exit</code>事件的回调函数里面，指定了一个下一轮事件循环，所要执行的操作。这是无效的，不会得到执行。</p>
<h3 id="beforeExit事件"><a href="#beforeExit事件" class="headerlink" title="beforeExit事件"></a>beforeExit事件</h3><p>beforeExit事件在Node清空了Event Loop以后，再没有任何待处理的任务时触发。正常情况下，如果没有任何待处理的任务，Node进程会自动退出，设置beforeExit事件的监听函数以后，就可以提供一个机会，再部署一些任务，使得Node进程不退出。</p>
<p>beforeExit事件与exit事件的主要区别是，beforeExit的监听函数可以部署异步任务，而exit不行。</p>
<p>此外，如果是显式终止程序（比如调用process.exit()），或者因为发生未捕获的错误，而导致进程退出，这些场合不会触发beforeExit事件。因此，不能使用该事件替代exit事件。</p>
<h3 id="uncaughtException事件"><a href="#uncaughtException事件" class="headerlink" title="uncaughtException事件"></a>uncaughtException事件</h3><p>当前进程抛出一个没有被捕捉的错误时，会触发<code>uncaughtException</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.error(<span class="string">'An uncaught error occurred!'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.error(err.stack);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'未捕获错误'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>部署<code>uncaughtException</code>事件的监听函数，是免于Node进程终止的最后措施，否则Node就要执行<code>process.exit()</code>。出于除错的目的，并不建议发生错误后，还保持进程运行。</p>
<p>抛出错误之前部署的异步操作，还是会继续执行。只有完成以后，Node进程才会退出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Caught exception: '</span> + err);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'本行依然执行'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">500</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的表达式抛出错误</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">nonexistentFunc();</span></pre></td></tr></table></figure>

<p>上面代码中，抛出错误之后，此前setTimeout指定的回调函数亦然会执行。</p>
<h3 id="信号事件"><a href="#信号事件" class="headerlink" title="信号事件"></a>信号事件</h3><p>操作系统内核向Node进程发出信号，会触发信号事件。实际开发中，主要对SIGTERM和SIGINT信号部署监听函数，这两个信号在非Windows平台会导致进程退出，但是只要部署了监听函数，Node进程收到信号后就不会退出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取标准输入，这主要是为了不让当前进程退出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">process.stdin.resume();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'SIGINT'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'SIGINT信号，按Control-D退出'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>上面代码部署了SIGINT信号的监听函数，当用户按下Ctrl-C后，会显示提示文字。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>José F. Romaniello, <a href="http://joseoncode.com/2014/07/21/graceful-shutdown-in-node-dot-js/" target="_blank" rel="noopener">Graceful shutdown in node.js</a></li>
</ul>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-04-14 </div>
			<div class="article-title"><a href="/2017/04/14/2017-04-14-node-js-path/" >Path 模块</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h2 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h2><p><code>path.join</code> 方法用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径<strong>分隔符</strong>，Unix 系统是 <code>”/“</code>，Windows 系统是 <code>”\“</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">path.join(mydir, &quot;foo&quot;);</span></pre></td></tr></table></figure>

<p>上面代码在 Unix 系统下，会返回路径 <code>mydir/foo</code>。</p>
<h2 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve()"></a>path.resolve()</h2><p><code>path.resolve</code>方法用于将相<strong>对路径转为绝对路径</strong>。</p>
<p>它可以接受多个参数，依次表示所要进入的路径，直到将<strong>最后一个参数</strong>转为绝对路径。如果根据参数无法得到绝对路径，就以当前所在路径作为基准。除了根目录，该方法的返回值都不带尾部的斜杠。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">path.resolve([<span class="keyword">from</span> ...], to)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'foo/bar'</span>, <span class="string">'/tmp/file/'</span>, <span class="string">'..'</span>, <span class="string">'a/../subfile'</span>)</span></pre></td></tr></table></figure>

<p>上面代码的实例，执行效果类似下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> foo/bar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /tmp/file/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ..</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> a/../subfile</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span></pre></td></tr></table></figure>

<p>更多例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'./baz'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// '/foo/bar/baz'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// '/tmp/file'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'wwwroot'</span>, <span class="string">'static_files/png/'</span>, <span class="string">'../gif/image.gif'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前目录是/home/myself/node，返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// /home/myself/node/wwwroot/static_files/gif/image.gif</span></span></pre></td></tr></table></figure>

<p>该方法忽略非字符串的参数。</p>
<h2 id="path-relative"><a href="#path-relative" class="headerlink" title="path.relative"></a>path.relative</h2><p><code>path.relative</code>方法接受两个参数，这两个参数都应该是绝对路径。该方法返回第二个路径相对于第一个路径的系统相对路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">path.relative(<span class="string">'/data/orandea/test/aaa'</span>, <span class="string">'/data/orandea/impl/bbb'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// '../../impl/bbb'</span></span></pre></td></tr></table></figure>

<p>上面代码中，如果当前目录是<code>/data/orandea/test/aaa</code>，进入<code>path.relative</code>返回的相对路径，就会到达<code>/data/orandea/impl/bbb</code>。</p>
<p>如果<code>path.relative</code>方法的两个参数相同，则返回一个空字符串。</p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/11/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/13/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Ajax/">Ajax<span>9</span></a></li>
		
			<li><a href="/categories/AliPay/">AliPay<span>1</span></a></li>
		
			<li><a href="/categories/Android/">Android<span>15</span></a></li>
		
			<li><a href="/categories/AngularJS/">AngularJS<span>4</span></a></li>
		
			<li><a href="/categories/BackEnd/">BackEnd<span>5</span></a></li>
		
			<li><a href="/categories/Backbone/">Backbone<span>1</span></a></li>
		
			<li><a href="/categories/Bootstrap/">Bootstrap<span>2</span></a></li>
		
			<li><a href="/categories/C-C/">C/C++<span>1</span></a></li>
		
			<li><a href="/categories/Car/">Car<span>1</span></a></li>
		
			<li><a href="/categories/Css/">Css<span>9</span></a></li>
		
			<li><a href="/categories/Css3/">Css3<span>4</span></a></li>
		
			<li><a href="/categories/Database/">Database<span>7</span></a></li>
		
			<li><a href="/categories/Design/">Design<span>1</span></a></li>
		
			<li><a href="/categories/Flutter/">Flutter<span>1</span></a></li>
		
			<li><a href="/categories/Git/">Git<span>1</span></a></li>
		
			<li><a href="/categories/Golang/">Golang<span>1</span></a></li>
		
			<li><a href="/categories/Hadoop/">Hadoop<span>1</span></a></li>
		
			<li><a href="/categories/Hexo/">Hexo<span>3</span></a></li>
		
			<li><a href="/categories/Html/">Html<span>18</span></a></li>
		
			<li><a href="/categories/Java/">Java<span>17</span></a></li>
		
			<li><a href="/categories/JavaScript/">JavaScript<span>82</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>8</span></a></li>
		
			<li><a href="/categories/Node-js/">Node.js<span>40</span></a></li>
		
			<li><a href="/categories/Powershell/">Powershell<span>1</span></a></li>
		
			<li><a href="/categories/Python/">Python<span>4</span></a></li>
		
			<li><a href="/categories/Read/">Read<span>9</span></a></li>
		
			<li><a href="/categories/Synology/">Synology<span>1</span></a></li>
		
			<li><a href="/categories/Testing/">Testing<span>4</span></a></li>
		
			<li><a href="/categories/Tools/">Tools<span>16</span></a></li>
		
			<li><a href="/categories/Vue-js/">Vue.js<span>10</span></a></li>
		
			<li><a href="/categories/WeChat/">WeChat<span>4</span></a></li>
		
			<li><a href="/categories/jQuery/">jQuery<span>5</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/docker/">docker<span>1</span></a></li>
		
			<li><a href="/tags/Library/">Library<span>7</span></a></li>
		
			<li><a href="/tags/Bom/">Bom<span>10</span></a></li>
		
			<li><a href="/tags/sqlite/">sqlite<span>3</span></a></li>
		
			<li><a href="/tags/Promise/">Promise<span>2</span></a></li>
		
			<li><a href="/tags/JSP/">JSP<span>1</span></a></li>
		
			<li><a href="/tags/Jasmine/">Jasmine<span>1</span></a></li>
		
			<li><a href="/tags/scrapy/">scrapy<span>1</span></a></li>
		
			<li><a href="/tags/Es6/">Es6+<span>2</span></a></li>
		
			<li><a href="/tags/MongoDB/">MongoDB<span>2</span></a></li>
		
			<li><a href="/tags/Chrome/">Chrome<span>2</span></a></li>
		
			<li><a href="/tags/Karma/">Karma<span>1</span></a></li>
		
			<li><a href="/tags/Document/">Document<span>8</span></a></li>
		
			<li><a href="/tags/StdLib/">StdLib<span>11</span></a></li>
		
			<li><a href="/tags/Performence/">Performence<span>1</span></a></li>
		
			<li><a href="/tags/gradle/">gradle<span>1</span></a></li>
		
			<li><a href="/tags/OOP/">OOP<span>9</span></a></li>
		
			<li><a href="/tags/Grammar/">Grammar<span>11</span></a></li>
		
			<li><a href="/tags/RegExp/">RegExp<span>2</span></a></li>
		
			<li><a href="/tags/Sublime/">Sublime<span>2</span></a></li>
		
		
		   <li><a href="/tags">...<span>28</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2020/11/30/2020-11-30-android-gradle/" ><i class="fa fa-file-o"></i>Gradle</a>
      </li>
    
      <li>
        <a href="/2020/11/29/2020-11-29-scrapy/" ><i class="fa fa-file-o"></i>Scrapy</a>
      </li>
    
      <li>
        <a href="/2020/11/26/2020-11-26-database-sqlite-exercise/" ><i class="fa fa-file-o"></i>SQLite Exercises</a>
      </li>
    
      <li>
        <a href="/2020/11/25/2020-11-25-database-sqlite-optimization/" ><i class="fa fa-file-o"></i>SQLite 性能优化</a>
      </li>
    
      <li>
        <a href="/2020/11/21/2020-11-21-database-sqlite/" ><i class="fa fa-file-o"></i>SQLite</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/freemind/" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/JesseQiu" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-linkedin"></i><a href="https://jesseqiu.github.io/" title="My Linkin account." target="_blank"]);">My LinkedIn</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>

  <div class="container-narrow">
  <footer> 
<!-- 不蒜子统计 -->

    <span id="busuanzi_container_site_pv">
            本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv" style='display:none'>
            本站访客数 <span id="busuanzi_value_site_uv"> </span>人
    </span>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<span>
  &copy; 2020 JesseChiu
  
</span>

<span>
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/" target="_blank" rel="noopener">Freemind</a>.    
</span>
 </footer>
</div> <!-- container-narrow -->

  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

  
</body>

   </html>
